<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>With config mappings it is possible to group multiple configuration properties in a single interface that
share the same prefix.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="config-mappings"><a class="anchor" href="#config-mappings"></a>1. <code>@ConfigMapping</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>A config mapping requires a public interface with minimal metadata configuration and annotated with the
<code>@io.smallrye.config.ConfigMapping</code> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping(prefix = "server")
public interface Server {
    String host();

    int port();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Server</code> interface is able to map configuration properties with the name <code>server.host</code> into the <code>Server.host()</code>
method and <code>server.port</code> into <code>Server.port()</code> method. The configuration property name to look up is built from the
prefix, and the method name with <code>.</code> (dot) as the separator.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a mapping fails to match a configuration property a <code>NoSuchElementException</code> is thrown, unless the mapped
element is an <code>Optional</code>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="registration"><a class="anchor" href="#registration"></a>1.1. Registration</h3>
<div class="paragraph">
<p>When a Quarkus application starts, a config mapping can be registered twice. One time for <em>STATIC INIT</em> and a second
time for <em>RUNTIME INIT</em>:</p>
</div>
<div class="sect3">
<h4 id="static-init"><a class="anchor" href="#static-init"></a>1.1.1. STATIC INIT</h4>
<div class="paragraph">
<p>Quarkus starts some of its services during static initialization, and <code>Config</code> is usually one of the first things that
is created. In certain situations it may not be possible to correctly initialize a config mapping. For instance, if the
mapping requires values from a custom <code>ConfigSource</code>. For this reason, any config mapping requires the annotation
<code>@io.quarkus.runtime.configuration.StaticInitSafe</code> to mark the mapping as safe to be used at this stage. Learn more
about <a href="config-extending-support#custom-config-source">registration</a> of a custom <code>ConfigSource</code>.</p>
</div>
<div class="sect4">
<h5 id="example"><a class="anchor" href="#example"></a>1.1.1.1. Example</h5>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@StaticInitSafe
@ConfigMapping(prefix = "server")
public interface Server {
    String host();

    int port();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="runtime-init"><a class="anchor" href="#runtime-init"></a>1.1.2. RUNTIME INIT</h4>
<div class="paragraph">
<p>The <em>RUNTIME INIT</em> stage happens after <em>STATIC INIT</em>. There are no restrictions at this stage, and any config mapping
is added to the <code>Config</code> instance as expected.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="retrieval"><a class="anchor" href="#retrieval"></a>1.2. Retrieval</h3>
<div class="paragraph">
<p>A config mapping interface can be injected into any CDI aware bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class BusinessBean {
    @Inject
    Server server;

    public void businessMethod() {
        String host = server.host();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In non-CDI contexts, use the API <code>io.smallrye.config.SmallRyeConfig#getConfigMapping</code> to retrieve the config mapping
instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">SmallRyeConfig config = ConfigProvider.getConfig().unwrap(SmallRyeConfig.class);
Server server = config.getConfigMapping(Server.class);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="nested-groups"><a class="anchor" href="#nested-groups"></a>1.3. Nested groups</h3>
<div class="paragraph">
<p>A nested mapping provides a way to subgroup other config properties:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping(prefix = "server")
public interface Server {
    String host();

    int port();

    Log log();

    interface Log {
        boolean enabled();

        String suffix();

        boolean rotate();
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.host=localhost
server.port=8080
server.log.enabled=true
server.log.suffix=.log
server.log.rotate=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method name of a mapping group acts as sub-namespace to the configurations properties.</p>
</div>
</div>
<div class="sect2">
<h3 id="overriding-property-names"><a class="anchor" href="#overriding-property-names"></a>1.4. Overriding property names</h3>
<div class="sect3">
<h4 id="withname"><a class="anchor" href="#withname"></a>1.4.1. <code>@WithName</code></h4>
<div class="paragraph">
<p>If a method name, or a property name do not match with each other, the <code>@WithName</code> annotation can override the method
name mapping and use the name supplied in the annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping(prefix = "server")
public interface Server {
    @WithName("name")
    String host();

    int port();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.name=localhost
server.port=8080</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="withparentname"><a class="anchor" href="#withparentname"></a>1.4.2. <code>@WithParentName</code></h4>
<div class="paragraph">
<p>The <code>@WithParentName</code> annotation allows to configurations mapping to inherit its container name, simplifying the
configuration property name required to match the mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">interface Server {
    @WithParentName
    ServerHostAndPort hostAndPort();

    @WithParentName
    ServerInfo info();
}

interface ServerHostAndPort {
    String host();

    int port();
}

interface ServerInfo {
    String name();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.host=localhost
server.port=8080
server.name=konoha</code></pre>
</div>
</div>
<div class="paragraph">
<p>Without the <code>@WithParentName</code> the method <code>name()</code> requires the configuration property <code>server.info.name</code>. Because we use
<code>@WithParentName</code>, the <code>info()</code> mapping will inherit the parent name from <code>Server</code> and <code>name()</code> maps to <code>server.name</code>
instead.</p>
</div>
</div>
<div class="sect3">
<h4 id="namingstrategy"><a class="anchor" href="#namingstrategy"></a>1.4.3. NamingStrategy</h4>
<div class="paragraph">
<p>Method names in camelCase map to kebab-case property names:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping(prefix = "server")
public interface Server {
    String theHost();

    int thePort();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.the-host=localhost
server.the-port=8080</code></pre>
</div>
</div>
<div class="paragraph">
<p>The mapping strategy can be adjusted by setting <code>namingStrategy</code> value in the <code>@ConfigMapping</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping(prefix = "server", namingStrategy = ConfigMapping.NamingStrategy.VERBATIM)
public interface ServerVerbatimNamingStrategy {
    String theHost();

    int thePort();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.theHost=localhost
server.thePort=8080</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>@ConfigMapping</code> annotation support the following naming strategies:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>KEBAB_CASE</code> (default) - The method name is derived by replacing case changes with a dash to map the configuration property.</p>
</li>
<li>
<p><code>VERBATIM</code> - The method name is used as is to map the configuration property.</p>
</li>
<li>
<p><code>SNAKE_CASE</code> - The method name is derived by replacing case changes with an underscore to map the configuration property.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="conversions"><a class="anchor" href="#conversions"></a>1.5. Conversions</h3>
<div class="paragraph">
<p>A config mapping class support automatic conversions of all types available for conversion in <code>Config</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping
public interface SomeTypes {
    @WithName("int")
    int intPrimitive();

    @WithName("int")
    Integer intWrapper();

    @WithName("long")
    long longPrimitive();

    @WithName("long")
    Long longWrapper();

    @WithName("float")
    float floatPrimitive();

    @WithName("float")
    Float floatWrapper();

    @WithName("double")
    double doublePrimitive();

    @WithName("double")
    Double doubleWrapper();

    @WithName("char")
    char charPrimitive();

    @WithName("char")
    Character charWrapper();

    @WithName("boolean")
    boolean booleanPrimitive();

    @WithName("boolean")
    Boolean booleanWrapper();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">int=9
long=9999999999
float=99.9
double=99.99
char=c
boolean=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is also valid for <code>Optional</code> and friends:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping
public interface Optionals {
    Optional&lt;Server&gt; server();

    Optional&lt;String&gt; optional();

    @WithName("optional.int")
    OptionalInt optionalInt();

    interface Server {
        String host();

        int port();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the mapping won&#8217;t fail if there is no configuration property to match the mapping.</p>
</div>
<div class="sect3">
<h4 id="withconverter"><a class="anchor" href="#withconverter"></a>1.5.1. <code>@WithConverter</code></h4>
<div class="paragraph">
<p>The <code>@WithConverter</code> annotation provides a way to set a <code>Converter</code> to use in a specific mapping:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping
public interface Converters {
    @WithConverter(FooBarConverter.class)
    String foo();
}

public static class FooBarConverter implements Converter&lt;String&gt; {
    @Override
    public String convert(final String value) {
        return "bar";
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">foo=foo</code></pre>
</div>
</div>
<div class="paragraph">
<p>A call to <code>Converters.foo()</code> results in the value <code>bar</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="collections"><a class="anchor" href="#collections"></a>1.5.2. Collections</h4>
<div class="paragraph">
<p>A config mapping is also able to map collections types <code>List</code> and <code>Set</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping(prefix = "server")
public interface ServerCollections {
    Set&lt;Environment&gt; environments();

    interface Environment {
        String name();

        List&lt;App&gt; apps();

        interface App {
            String name();

            List&lt;String&gt; services();

            Optional&lt;List&lt;String&gt;&gt; databases();
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.environments[0].name=dev
server.environments[0].apps[0].name=rest
server.environments[0].apps[0].services=bookstore,registration
server.environments[0].apps[0].databases=pg,h2
server.environments[0].apps[1].name=batch
server.environments[0].apps[1].services=stock,warehouse</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>List</code> or <code>Set</code> mappings can use <a href="config-reference#indexed-properties">indexed properties</a> to map
configuration values in mapping groups. For collection with simple element types like <code>String</code>, their configuration
value is a comma separated string.</p>
</div>
</div>
<div class="sect3">
<h4 id="maps"><a class="anchor" href="#maps"></a>1.5.3. Maps</h4>
<div class="paragraph">
<p>A config mapping is also able to map a <code>Map</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping(prefix = "server")
public interface Server {
    String host();

    int port();

    Map&lt;String, String&gt; form();
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">application.properties</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">server.host=localhost
server.port=8080
server.form.login-page=login.html
server.form.error-page=error.html
server.form.landing-page=index.html</code></pre>
</div>
</div>
<div class="paragraph">
<p>The configuration property needs to specify an additional name to act as the key. In this case the <code>form()</code> <code>Map</code> will
contain three elements with the keys <code>login-page</code>, <code>error-page</code> and <code>landing-page</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="defaults"><a class="anchor" href="#defaults"></a>1.6. Defaults</h3>
<div class="paragraph">
<p>The <code>@WithDefault</code> annotation allows to set a default property into a mapping (and prevent and error if the
configuration value is not available in any <code>ConfigSource</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface Defaults {
    @WithDefault("foo")
    String foo();

    @WithDefault("bar")
    String bar();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>No configuration properties required. The <code>Defaults.foo()</code> will return the value <code>foo</code> and <code>Defaults.bar()</code> will return
the value <code>bar</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="validation"><a class="anchor" href="#validation"></a>1.7. Validation</h3>
<div class="paragraph">
<p>A config mapping may combine annotations from <a href="https://beanvalidation.org">Bean Validation</a> to validate configuration
values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping(prefix = "server")
public interface Server {
    @Size(min = 2, max = 20)
    String host();

    @Max(10000)
    int port();
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
For validation to work, the <code>quarkus-hibernate-validator</code> extension is required, and it is performed
automatically.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mocking"><a class="anchor" href="#mocking"></a>1.8. Mocking</h3>
<div class="paragraph">
<p>A mapping interface implementation is not a proxy, so it cannot be mocked directly with <code>@InjectMock</code> like other CDI
beans. One trick is to make it proxyable with a producer method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ServerMockProducer {
    @Inject
    Config config;

    @Produces
    @ApplicationScoped
    @io.quarkus.test.Mock
    Server server() {
        return config.unwrap(SmallRyeConfig.class).getConfigMapping(Server.class);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Server</code> can be injected as a mock into a Quarkus test class with <code>@InjectMock</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
class ServerMockTest {
    @InjectMock
    Server server;

    @Test
    void localhost() {
        Mockito.when(server.host()).thenReturn("localhost");
        assertEquals("localhost", server.host());
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The mock is just an empty shell without any actual configuration values.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the goal is to only mock certain configuration values and retain the original configuration, the mocking instance
requires a spy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConfigMapping(prefix = "app")
public interface AppConfig {
    @WithDefault("app")
    String name();

    Info info();

    interface Info {
        @WithDefault("alias")
        String alias();
        @WithDefault("10")
        Integer count();
    }
}

public static class AppConfigProducer {
    @Inject
    Config config;

    @Produces
    @ApplicationScoped
    @io.quarkus.test.Mock
    AppConfig appConfig() {
        AppConfig appConfig = config.unwrap(SmallRyeConfig.class).getConfigMapping(AppConfig.class);
        AppConfig appConfigSpy = Mockito.spy(appConfig);
        AppConfig.Info infoSpy = Mockito.spy(appConfig.info());
        Mockito.when(appConfigSpy.info()).thenReturn(infoSpy);
        return appConfigSpy;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>AppConfig</code> can be injected as a mock into a Quarkus test class with <code>@Inject</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
class AppConfigTest {
    @Inject
    AppConfig appConfig;

    @Test
    void localhost() {
        Mockito.when(appConfig.name()).thenReturn("mocked-app");
        assertEquals("mocked-app", server.host());

        Mockito.when(appConfig.info().alias()).thenReturn("mocked-alias");
        assertEquals("mocked-alias", server.info().alias());
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Nested elements need to be spied individually by Mockito.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>