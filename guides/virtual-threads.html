<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Unresolved directive in _attributes.adoc - include::_attributes-local.adoc[]
:resteasy-reactive-api: <a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive/3.2.0.Final" class="bare">https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive/3.2.0.Final</a>
:resteasy-reactive-common-api: <a href="https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/3.2.0.Final" class="bare">https://javadoc.io/doc/io.quarkus.resteasy.reactive/resteasy-reactive-common/3.2.0.Final</a>
:runonvthread: <a href="https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/latest/io/smallrye/common/annotation/RunOnVirtualThread.html" class="bare">https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/latest/io/smallrye/common/annotation/RunOnVirtualThread.html</a>
:blockingannotation: <a href="https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/latest/io/smallrye/common/annotation/Blocking.html" class="bare">https://javadoc.io/doc/io.smallrye.common/smallrye-common-annotation/latest/io/smallrye/common/annotation/Blocking.html</a>
:vthreadjep: <a href="https://openjdk.org/jeps/425" class="bare">https://openjdk.org/jeps/425</a>
:thread: <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Thread.html" class="bare">https://docs.oracle.com/en/java/javase/18/docs/api/java.base/java/lang/Thread.html</a>
:mutiny-vertx-sql: <a href="https://smallrye.io/smallrye-mutiny-vertx-bindings/2.26.0/apidocs/io/vertx/mutiny/sqlclient/package-summary.html" class="bare">https://smallrye.io/smallrye-mutiny-vertx-bindings/2.26.0/apidocs/io/vertx/mutiny/sqlclient/package-summary.html</a>
:pgsql-driver: <a href="https://javadoc.io/doc/org.postgresql/postgresql/latest/index.html" class="bare">https://javadoc.io/doc/org.postgresql/postgresql/latest/index.html</a></p>
</div>
<div class="paragraph">
<p>This guide explains how to benefit from Java 19 virtual threads when writing REST services in Quarkus.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>This is the reference guide for using virtual threads to write reactive REST services.
Please refer to the <a href="rest-json">Writing JSON REST services guides</a> for a lightweight introduction to reactive REST
services and to the <a href="resteasy-reactive">Writing REST Services with RESTEasy Reactive</a> guide for a detailed presentation.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="what-are-virtual-threads"><a class="anchor" href="#what-are-virtual-threads"></a>What are virtual threads ?</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="terminology"><a class="anchor" href="#terminology"></a>Terminology</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">OS thread</dt>
<dd>
<p>A "thread-like" data-structure managed by the Operating System.</p>
</dd>
<dt class="hdlist1">Platform thread</dt>
<dd>
<p>Up until Java 19, every instance of the <a href="{thread}">Thread</a> class was a platform thread, that is, a wrapper around an OS thread.
Creating a platform threads creates an OS thread, blocking a platform thread blocks an OS thread.</p>
</dd>
<dt class="hdlist1">Virtual thread</dt>
<dd>
<p>Lightweight, JVM-managed threads. They extend the <a href="{thread}">Thread</a> class but are not tied to one specific OS thread.
Thus, scheduling virtual threads is the responsibility of the JVM.</p>
</dd>
<dt class="hdlist1">Carrier thread</dt>
<dd>
<p>A platform thread used to execute a virtual thread is called a carrier.
This isn&#8217;t a class distinct from <a href="{Thread}">Thread</a> or VirtualThread but rather a functional denomination.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="differences-between-virtual-threads-and-platform-threads"><a class="anchor" href="#differences-between-virtual-threads-and-platform-threads"></a>Differences between virtual threads and platform threads</h3>
<div class="paragraph">
<p>We will give a brief overview of the topic here, please refer to the <a href="{vthreadjep}">JEP 425</a> for more information.</p>
</div>
<div class="paragraph">
<p>Virtual threads are a feature available since Java 19 aiming at providing a cheap alternative to platform threads for I/O-bound workloads.</p>
</div>
<div class="paragraph">
<p>Until now, platform threads were the concurrency unit of the JVM.
They are a wrapper over OS structures.
This means that creating a Java platform thread actually results in creating a "thread-like" structure in your operating system.</p>
</div>
<div class="paragraph">
<p>Virtual threads on the other hand are managed by the JVM. In order to be executed, they need to be mounted on a platform thread
(which acts as a carrier to that virtual thread).
As such, they have been designed to offer the following characteristics:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Lightweight </dt>
<dd>
<p>Virtual threads occupy less space than platform threads in memory.
Hence, it becomes possible to use more virtual threads than platform threads simultaneously without blowing up the heap.
By default, platform threads are created with a stack of about 1 MB where virtual threads stack is "pay-as-you-go".
You can find these numbers along with other motivations for virtual threads in this presentation given by the lead developer of project Loom: <a href="https://youtu.be/lIq-x_iI-kc?t=543" class="bare">https://youtu.be/lIq-x_iI-kc?t=543</a>.</p>
</dd>
<dt class="hdlist1">Cheap to create</dt>
<dd>
<p>Creating a platform thread in Java takes time.
Currently, techniques such as pooling where threads are created once then reused are strongly encouraged to minimize the
time lost in starting them (as well as limiting the maximum number of threads to keep memory consumption low).
Virtual threads are supposed to be disposable entities that we create when we need them,
it is discouraged to pool them or to reuse them for different tasks.</p>
</dd>
<dt class="hdlist1">Cheap to block</dt>
<dd>
<p>When performing blocking I/O, the underlying OS thread wrapped by the Java platform thread is put in a
wait queue and a context switch occurs to load a new thread context onto the CPU core. This operation takes time.
Since virtual threads are managed by the JVM, no underlying OS thread is blocked when they perform a blocking operation.
Their state is simply stored in the heap and another Virtual thread is executed on the same Java platform thread.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="virtual-threads-are-useful-for-io-bound-workloads-only"><a class="anchor" href="#virtual-threads-are-useful-for-io-bound-workloads-only"></a>Virtual threads are useful for I/O-bound workloads only</h3>
<div class="paragraph">
<p>We now know that we can create way more virtual threads than platform threads. One could be tempted to use virtual threads
to perform long computations (CPU-bound workload).
This is useless if not counterproductive.
CPU-bound doesn&#8217;t consist in quickly swapping threads while they need to wait for the completion of an I/O but in leaving
them attached to a CPU-core to actually compute something.
In this scenario, it is useless to have thousands of threads if we have tens of CPU-cores, virtual threads won&#8217;t enhance
the performance of CPU-bound workloads.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bringing-virtual-threads-to-reactive-rest-services"><a class="anchor" href="#bringing-virtual-threads-to-reactive-rest-services"></a>Bringing virtual threads to reactive REST services</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since virtual threads are disposable entities, the fundamental idea of quarkus-loom is to offload the execution of an
endpoint handler on a new virtual thread instead of running it on an event-loop (in the case of RESTeasy-reactive) or a
platform worker thread.</p>
</div>
<div class="paragraph">
<p>To do so, it suffices to add the <a href="{runonvthread}">@RunOnVirtualThread</a> annotation to the endpoint.
If the JDK is compatible (Java 19 or later versions) then the endpoint will be offloaded to a virtual thread.
It will then be possible to perform blocking operations without blocking the platform thread upon which the virtual
thread is mounted.</p>
</div>
<div class="paragraph">
<p>This annotation can only be used in conjunction with endpoints annotated with <a href="{blockingannotation}">@Blocking</a> or
considered blocking because of their signature.
You can visit <a href="resteasy-reactive#execution-model-blocking-non-blocking">Execution model, blocking, non-blocking</a>
for more information.</p>
</div>
<div class="sect2">
<h3 id="getting-started"><a class="anchor" href="#getting-started"></a>Getting started</h3>
<div class="paragraph">
<p>Add the following import to your build file:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-resteasy-reactive&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-resteasy-reactive")</code></pre>
</div>
</div>
<div class="paragraph">
<p>You also need to make sure that you are using the version 19 of Java, this can be enforced in your pom.xml file with the following:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;properties&gt;
    &lt;maven.compiler.source&gt;19&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;19&lt;/maven.compiler.target&gt;
&lt;/properties&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Virtual threads are still an experimental feature, you need to start your application with the <code>--enable-preview</code> flag:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">java --enable-preview -jar target/quarkus-app/quarkus-run.jar</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example below shows the differences between three endpoints, all of them querying a fortune in the database then
returning it to the client.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the first one uses the traditional blocking style, it is considered blocking due to its signature.</p>
</li>
<li>
<p>the second one uses Mutiny reactive streams in a declarative style, it is considered non-blocking due to its signature.</p>
</li>
<li>
<p>the third one uses Mutiny reactive streams in a synchronous way, since it doesn&#8217;t return a "reactive type" it is
considered blocking and the <a href="{runonvthread}">@RunOnVirtualThread</a> annotation can be used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using Mutiny, alternative "xAndAwait" methods are provided to be used with virtual threads.
They ensure that waiting for the completion of the I/O will not "pin" the carrier thread and deteriorate performance.
Pinning is a phenomenon that we describe in <a href="#pinning-cases">this section</a>.</p>
</div>
<div class="paragraph">
<p>In other words, the mutiny environment is a safe environment for virtual threads.
The guarantees offered by Mutiny are detailed later.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import org.acme.fortune.model.Fortune;
import org.acme.fortune.repository.FortuneRepository;
import io.smallrye.common.annotation.RunOnVirtualThread;
import io.smallrye.mutiny.Uni;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import java.util.List;
import java.util.Random;


@Path("")
public class FortuneResource {

    @GET
    @Path("/blocking")
    public Fortune blocking() {
        var list = repository.findAllBlocking();
        return pickOne(list);
    }

    @GET
    @Path("/reactive")
    public Uni&lt;Fortune&gt; reactive() {
        return repository.findAllAsync()
                .map(this::pickOne);
    }

    @GET
    @Path("/virtual")
    @RunOnVirtualThread
    public Fortune virtualThread() {
        var list = repository.findAllAsyncAndAwait();
        return pickOne(list);
    }

}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="simplifying-complex-logic"><a class="anchor" href="#simplifying-complex-logic"></a>Simplifying complex logic</h3>
<div class="paragraph">
<p>The previous example is trivial and doesn&#8217;t capture how imperative style can simplify complex reactive operations.
Below is a more complex example.
The endpoints must now fetch all the fortunes in the database, then append a quote to each fortune before finally returning
the result to the client.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.rest;

import org.acme.fortune.model.Fortune;
import org.acme.fortune.repository.FortuneRepository;
import io.smallrye.common.annotation.RunOnVirtualThread;
import io.smallrye.mutiny.Uni;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import java.util.List;
import java.util.Random;


@Path("")
public class FortuneResource {

    private final FortuneRepository repository;

    public Uni&lt;List&lt;String&gt;&gt; getQuotesAsync(int size){
        //...
        //asynchronously returns a list of quotes from an arbitrary source
    }

    @GET
    @Path("/quoted-blocking")
    public List&lt;Fortune&gt; getAllQuotedBlocking() {
        // we get the list of fortunes
        var fortunes = repository.findAllBlocking();

        // we get the list of quotes
        var quotes = getQuotesAsync(fortunes.size()).await().indefinitely();

        // we append each quote to each fortune
        for(int i=0; i  &lt; fortunes.size(); i ++){
            fortunes.get(i).title += "   -  " + quotes.get(i);
        }
        return fortunes;
    }

    @GET
    @Path("/quoted-reactive")
    public Uni&lt;List&lt;Fortune&gt;&gt; getAllQuotedReactive() {
        // we first fetch the list of resource and we memoize it
        // to avoid fetching it again everytime need it
        var fortunes = repository.findAllAsync().memoize().indefinitely();

        // once we get a result for fortunes,
        // we know its size and can thus query the right number of quotes
        var quotes = fortunes.onItem().transformToUni(list -&gt; getQuotesAsync(list.size()));

        // we now need to combine the two reactive streams
        // before returning the result to the user
        return Uni.combine().all().unis(fortunes, quotes).asTuple().onItem().transform(tuple -&gt; {
            var todoList = tuple.getItem1();
            //can await it since it is already resolved
            var quotesList = tuple.getItem2();
            for(int i=0; i  &lt; todoList.size(); i ++){
                todoList.get(i).title += "   -  " + quotesList.get(i);
            }
            return todoList;
        });
    }

    @GET
    @RunOnVirtualThread
    @Path("/quoted-virtual-thread")
    public List&lt;Fortune&gt; getAllQuotedVirtualThread() {
        //we get the list of fortunes
        var fortunes = repository.findAllAsyncAndAwait();

        //we get the list of quotes
        var quotes = getQuotesAsync(fortunes.size()).await().indefinitely();

        //we append each quote to each fortune
        for(int i=0; i  &lt; fortunes.size(); i ++){
            fortunes.get(i).title += "   -  " + quotes.get(i);
        }
        return fortunes;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pinning-cases"><a class="anchor" href="#pinning-cases"></a>Pinning cases</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The notion of "cheap blocking" might not always be true: in certain occasions a virtual thread might "pin" its carrier
(the platform thread it is mounted upon).
In this situation, the platform thread is blocked exactly as it would have been in a typical blocking scenario.</p>
</div>
<div class="paragraph">
<p>According to <a href="{vthreadjep}">JEP 425</a> this can happen in two situations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>when a virtual thread performs a blocking operation inside a <code>synchronized</code> block or method</p>
</li>
<li>
<p>when it executes a blocking operation inside a native method or a foreign function</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>It can be fairly easy to avoid these situations in our own code, but it is hard to verify every dependency we use.
Typically, while experimenting with virtual-threads, we realized that using the <a href="{pgsql-driver}">postgresql-JDBC driver</a>
results in frequent pinning.</p>
</div>
<div class="sect2">
<h3 id="the-jdbc-problem"><a class="anchor" href="#the-jdbc-problem"></a>The JDBC problem</h3>
<div class="paragraph">
<p>Our experiments so far show that when a virtual thread queries a database using the JDBC driver, it will pin its carrier
thread during the entire operation.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s show the code of the <code>findAllBlocking()</code> method we used in the first example</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//import ...

@ApplicationScoped
public class FortuneRepository {
    // ...

    public List&lt;Fortune&gt; findAllBlocking() {
        List&lt;Fortune&gt; fortunes = new ArrayList&lt;&gt;();
        Connection conn = null;
        try {
            conn = db.getJdbcConnection();
            var preparedStatement = conn.prepareStatement(SELECT_ALL);
            ResultSet rs = preparedStatement.executeQuery();
            while (rs.next()) {
                fortunes.add(create(rs));
            }
            rs.close();
            preparedStatement.close();
        } catch (SQLException e) {
            logger.warn("Unable to retrieve fortunes from the database", e);
        } finally {
           close(conn);
        }
        return fortunes;
    }

    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The actual query happens at <code>ResultSet rs = preparedStatement.executeQuery();</code>, here is how it is implemented in the
postgresql-jdbc driver 42.5.0:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class PgPreparedStatement extends PgStatement implements PreparedStatement {
    // ...

    /*
    * A Prepared SQL query is executed and its ResultSet is returned
    *
    * @return a ResultSet that contains the data produced by the * query - never null
    *
    * @exception SQLException if a database access error occurs
    */
    @Override
    public ResultSet executeQuery() throws SQLException {
        synchronized (this) {
            if (!executeWithFlags(0)) {
                throw new PSQLException(GT.tr("No results were returned by the query."), PSQLState.NO_DATA);
            }
            return getSingleResultSet();
        }
    }

    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This <code>synchronized</code> block is the culprit.
Replacing it with a lock is a good solution, but it won&#8217;t be enough: <code>synchronized</code> blocks are also used in <code>executeWithFlags(int flag)</code>.
A systematic review of the postgresql-jdbc driver is necessary to make sure that it is compliant with virtual threads.</p>
</div>
</div>
<div class="sect2">
<h3 id="reactive-drivers-at-the-rescue"><a class="anchor" href="#reactive-drivers-at-the-rescue"></a>Reactive drivers at the rescue</h3>
<div class="paragraph">
<p>The vertx-sql-client is a reactive client, hence it is not supposed to block while waiting for the completion of a
transaction with the database.
However, when using the <a href="{mutiny-vertx-sql}">smallrye-mutiny-vertx-sqlclient</a> it is possible to use a variant method
that will await for the completion of the transaction, mimicking a blocking behaviour.</p>
</div>
<div class="paragraph">
<p>Below is the <code>FortuneRepository</code> except the blocking we&#8217;ve seen earlier has been replaced by reactive methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">//import ...

@ApplicationScoped
public class FortuneRepository {
    // ...

    public Uni&lt;List&lt;Fortune&gt;&gt; findAllAsync() {
        return db.getPool()
                .preparedQuery(SELECT_ALL).execute()
                .map(this::createListOfFortunes);

    }

    public List&lt;Fortune&gt; findAllAsyncAndAwait() {
        var rows = db.getPool().preparedQuery(SELECT_ALL)
                .executeAndAwait();
        return createListOfFortunes(rows);
    }

    //...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Contrary to the <a href="{pgsql-driver}">postgresql-jdbc driver</a>, no <code>synchronized</code> block is used where it shouldn&#8217;t be, and
the <code>await</code> behaviour is implemented using locks and latches that won&#8217;t cause pinning.</p>
</div>
<div class="paragraph">
<p>Using the synchronous methods of the <a href="{mutiny-vertx-sql}">smallrye-mutiny-vertx-sqlclient</a> along with virtual threads
will allow you to use the synchronous blocking style, avoid pinning the carrier thread, and get performance close to a pure
reactive implementation.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="a-point-about-performance"><a class="anchor" href="#a-point-about-performance"></a>A point about performance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Our experiments seem to indicate that Quarkus with virtual threads will scale better than Quarkus blocking (offloading
the computation on a pool of platform worker threads) but not as well as Quarkus reactive.
The memory consumption especially might be an issue: if your system needs to keep its memory footprint low we would
advise you stick to using reactive constructs.</p>
</div>
<div class="paragraph">
<p>This degradation of performance doesn&#8217;t seem to come from virtual threads themselves but from the interactions between
Vert.x/Netty (Quarkus underlying reactive engine) and the virtual threads.
This was illustrated in the issue that we will now describe.</p>
</div>
<div class="sect2">
<h3 id="the-netty-problem"><a class="anchor" href="#the-netty-problem"></a>The Netty problem</h3>
<div class="paragraph">
<p>For JSON serialization, Netty uses their custom implementation of thread locals, <code>FastThreadLocal</code> to store buffers.
When using virtual threads in quarkus, the number of virtual threads simultaneously living in the service is directly
related to the incoming traffic.
It is possible to get hundreds of thousands, if not millions, of them.</p>
</div>
<div class="paragraph">
<p>If they need to serialize some data to JSON they will end up creating as many instances of <code>FastThreadLocal</code>, resulting
on a massive memory consumption as well as exacerbated pressure on the garbage collector.
This will eventually affect the performance of the application and inhibit its scalability.</p>
</div>
<div class="paragraph">
<p>This is a perfect example of the mismatch between the reactive stack and the virtual threads.
The fundamental hypothesis are completely different and result in different optimizations.
Netty expects a system using few event-loops (as many event-loops as CPU cores by default in Quarkus), but it gets hundreds
of thousands of threads.
You can refer to <a href="https://mail.openjdk.org/pipermail/loom-dev/2022-July/004844.html">this mail</a> to get more information
on how we envision our future with virtual threads.</p>
</div>
</div>
<div class="sect2">
<h3 id="our-solution-to-the-netty-problem"><a class="anchor" href="#our-solution-to-the-netty-problem"></a>Our solution to the Netty problem</h3>
<div class="paragraph">
<p>In order to avoid this wasting of resource without modifying Netty upstream, we wrote an extension that modifies the
bytecode of the class responsible for creating the thread locals at build time.
Using this extension, performance of virtual threads in Quarkus for the Json Serialization test of the Techempower suite
increased by nearly 80%, making it almost as good as reactive endpoints.</p>
</div>
<div class="paragraph">
<p>To use it, it needs to be added as a dependency:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-netty-loom-adaptor&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Furthermore, some operations undertaken by this extension need special access, it is necessary to</p>
</div>
<div class="ulist">
<ul>
<li>
<p>compile the application with the flag <code>-Dnet.bytebuddy.experimental</code></p>
</li>
<li>
<p>open the <code>java.base.lang</code> module at runtime with the flag <code>--add-opens java.base/java.lang=ALL-UNNAMED</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This extension is only intended to improve performance, it is perfectly fine not to use it.</p>
</div>
</div>
<div class="sect2">
<h3 id="concerning-dev-mode"><a class="anchor" href="#concerning-dev-mode"></a>Concerning dev mode</h3>
<div class="paragraph">
<p>If you want to use quarkus with the dev mode, it won&#8217;t be possible to manually specify the flags we mentioned along this guide.
Instead, you want to specify them all in the configuration of the <code>quarkus-maven-plugin</code> as presented below.</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;${quarkus.version}&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;goals&gt;
                &lt;goal&gt;build&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;

    &lt;configuration&gt;
      &lt;source&gt;19&lt;/source&gt;
      &lt;target&gt;19&lt;/target&gt;
      &lt;compilerArgs&gt;
        &lt;arg&gt;--enable-preview&lt;/arg&gt;
        &lt;arg&gt;-Dnet.bytebuddy.experimental&lt;/arg&gt;
      &lt;/compilerArgs&gt;
      &lt;jvmArgs&gt;--enable-preview --add-opens java.base/java.lang=ALL-UNNAMED&lt;/jvmArgs&gt;
    &lt;/configuration&gt;

&lt;/plugin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you don&#8217;t want to specify the opening of the <code>java.lang</code> module in your pom.xml file, you can also specify it as an argument
when you start the dev mode.</p>
</div>
<div class="paragraph">
<p>The configuration of the quarkus-maven-plugin will be simpler:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    &lt;configuration&gt;
      &lt;source&gt;19&lt;/source&gt;
      &lt;target&gt;19&lt;/target&gt;
      &lt;compilerArgs&gt;
        &lt;arg&gt;--enable-preview&lt;/arg&gt;
        &lt;arg&gt;-Dnet.bytebuddy.experimental&lt;/arg&gt;
      &lt;/compilerArgs&gt;
      &lt;jvmArgs&gt;--enable-preview&lt;/jvmArgs&gt;
    &lt;/configuration&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the command will become:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">mvn quarkus:dev -Dopen-lang-package</code></pre>
</div>
</div>
</div>
</div>
</div>