<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus comes with a Transaction Manager and uses it to coordinate and expose transactions to your applications.
Each extension dealing with persistence will integrate with it for you.
And you will explicitly interact with transactions via CDI.
This guide will walk you through all that.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting-it-up"><a class="anchor" href="#setting-it-up"></a>Setting it up</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You don&#8217;t need to worry about setting it up most of the time as extensions needing it will simply add it as a dependency.
Hibernate ORM for example will include the transaction manager and set it up properly.</p>
</div>
<div class="paragraph">
<p>You might need to add it as a dependency explicitly if you are using transactions directly without Hibernate ORM for example.
Add the following to your build file:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-narayana-jta&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-narayana-jta")</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="starting-and-stopping-transactions-defining-your-boundaries"><a class="anchor" href="#starting-and-stopping-transactions-defining-your-boundaries"></a>Starting and stopping transactions: defining your boundaries</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can define your transaction boundaries either declaratively with <code>@Transactional</code> or programmatically with <code>QuarkusTransaction</code>. You can also use
the JTA <code>UserTransaction</code> API directly, however this is less user-friendly than <code>QuarkusTransaction</code>.</p>
</div>
<div class="sect2">
<h3 id="declarative-approach"><a class="anchor" href="#declarative-approach"></a>Declarative approach</h3>
<div class="paragraph">
<p>The easiest way to define your transaction boundaries is to use the <code>@Transactional</code> annotation on your entry method (<code>jakarta.transaction.Transactional</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class SantaClausService {

    @Inject ChildDAO childDAO;
    @Inject SantaClausDAO santaDAO;

    @Transactional <i class="conum" data-value="1"></i><b>(1)</b>
    public void getAGiftFromSanta(Child child, String giftDescription) {
        // some transaction work
        Gift gift = childDAO.addToGiftList(child, giftDescription);
        if (gift == null) {
            throw new OMGGiftNotRecognizedException(); <i class="conum" data-value="2"></i><b>(2)</b>
        }
        else {
            santaDAO.addToSantaTodoList(gift);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This annotation defines your transaction boundaries and will wrap this call within a transaction.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>A <code>RuntimeException</code> crossing the transaction boundaries will roll back the transaction.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>@Transactional</code> can be used to control transaction boundaries on any CDI bean at the method level or at the class level to ensure every method is transactional.
That includes REST endpoints.</p>
</div>
<div class="paragraph">
<p>You can control whether and how the transaction is started with parameters on <code>@Transactional</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Transactional(REQUIRED)</code> (default): starts a transaction if none was started, stays with the existing one otherwise.</p>
</li>
<li>
<p><code>@Transactional(REQUIRES_NEW)</code>: starts a transaction if none was started ; if an existing one was started, suspends it and starts a new one for the boundary of that method.</p>
</li>
<li>
<p><code>@Transactional(MANDATORY)</code>: fails if no transaction was started ; works within the existing transaction otherwise.</p>
</li>
<li>
<p><code>@Transactional(SUPPORTS)</code>: if a transaction was started, joins it ; otherwise works with no transaction.</p>
</li>
<li>
<p><code>@Transactional(NOT_SUPPORTED)</code>: if a transaction was started, suspends it and works with no transaction for the boundary of the method ; otherwise works with no transaction.</p>
</li>
<li>
<p><code>@Transactional(NEVER)</code>: if a transaction was started, raises an exception ; otherwise works with no transaction.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>REQUIRED</code> or <code>NOT_SUPPORTED</code> are probably the most useful ones.
This is how you decide whether a method is to be running within or outside a transaction.
Make sure to check the JavaDoc for the precise semantic.</p>
</div>
<div class="paragraph">
<p>The transaction context is propagated to all calls nested in the <code>@Transactional</code> method as you would expect (in this example <code>childDAO.addToGiftList()</code> and <code>santaDAO.addToSantaTodoList()</code>).
The transaction will commit unless a runtime exception crosses the method boundary.
You can override whether an exception forces the rollback or not by using <code>@Transactional(dontRollbackOn=SomeException.class)</code> (or <code>rollbackOn</code>).</p>
</div>
<div class="paragraph">
<p>You can also programmatically ask for a transaction to be marked for rollback.
Inject a <code>TransactionManager</code> for this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class SantaClausService {

    @Inject TransactionManager tm; <i class="conum" data-value="1"></i><b>(1)</b>
    @Inject ChildDAO childDAO;
    @Inject SantaClausDAO santaDAO;

    @Transactional
    public void getAGiftFromSanta(Child child, String giftDescription) {
        // some transaction work
        Gift gift = childDAO.addToGiftList(child, giftDescription);
        if (gift == null) {
            tm.setRollbackOnly(); <i class="conum" data-value="2"></i><b>(2)</b>
        }
        else {
            santaDAO.addToSantaTodoList(gift);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inject the <code>TransactionManager</code> to be able to activate <code>setRollbackOnly</code> semantic.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Programmatically decide to set the transaction for rollback.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="transaction-configuration"><a class="anchor" href="#transaction-configuration"></a>Transaction Configuration</h3>
<div class="paragraph">
<p>Advanced configuration of the transaction is possible with the use of the <code>@TransactionConfiguration</code> annotation that is set in addition to the standard <code>@Transactional</code> annotation on your entry method or at the class level.</p>
</div>
<div class="paragraph">
<p>The <code>@TransactionConfiguration</code> annotation allows to set a timeout property, in seconds, that applies to transactions created within the annotated method.</p>
</div>
<div class="paragraph">
<p>This annotation may only be placed on the top level method delineating the transaction.
Annotated nested methods once a transaction has started will throw an exception.</p>
</div>
<div class="paragraph">
<p>If defined on a class, it is equivalent to defining it on all the methods of the class marked with <code>@Transactional</code>.
The configuration defined on a method takes precedence over the configuration defined on a class.</p>
</div>
</div>
<div class="sect2">
<h3 id="reactive-extensions"><a class="anchor" href="#reactive-extensions"></a>Reactive extensions</h3>
<div class="paragraph">
<p>If your <code>@Transactional</code>-annotated method returns a reactive value, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CompletionStage</code> (from the JDK)</p>
</li>
<li>
<p><code>Publisher</code> (from  Reactive-Streams)</p>
</li>
<li>
<p>Any type which can be converted to one of the two previous types using Reactive Type Converters</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>then the behaviour is a bit different, because the transaction will not be terminated until the
returned reactive value is terminated. In effect, the returned reactive value will be listened to
and if it terminates exceptionally the transaction will be marked for rollback, and will be committed
or rolled-back only at termination of the reactive value.</p>
</div>
<div class="paragraph">
<p>This allows your reactive methods to keep on working on the transaction asynchronously until their
work is really done, and not just until the reactive method returns.</p>
</div>
<div class="paragraph">
<p>If you need to propagate your transaction context across your reactive pipeline, please see the
<a href="context-propagation">Context Propagation guide</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="programmatic-approach"><a class="anchor" href="#programmatic-approach"></a>Programmatic Approach</h3>
<div class="paragraph">
<p>You can use static methods on <code>QuarkusTransaction</code> to define transaction boundaries. This provides two different options,
a functional approach that allows you to run a lambda within the scope of a transaction, or by using explicit <code>begin</code>,
<code>commit</code> and <code>rollback</code> methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.narayana.jta.QuarkusTransaction;
import io.quarkus.narayana.jta.RunOptions;

public class TransactionExample {

    public void beginExample() {
        QuarkusTransaction.begin();
        //do work
        QuarkusTransaction.commit();

        QuarkusTransaction.begin(QuarkusTransaction.beginOptions()
                .timeout(10));
        //do work
        QuarkusTransaction.rollback();
    }

    public void runnerExample() {
        QuarkusTransaction.requiringNew().run(() -&gt; {
            //do work
        });
        QuarkusTransaction.joiningExisting().run(() -&gt; {
            //do work
        });

        int result = QuarkusTransaction.requiringNew()
                .timeout(10)
                .exceptionHandler((throwable) -&gt; {
                    if (throwable instanceof SomeException) {
                        return RunOptions.ExceptionResult.COMMIT;
                    }
                    return TransactionExceptionResult.ROLLBACK;
                })
                .call(() -&gt; {
                    //do work
                    return 0;
                });
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The above example shows a few different ways the API can be used.</p>
</div>
<div class="paragraph">
<p>The first method simply calls begin, does some work and commits it.
This created transaction is tied to the CDI request scope, so if it is still active when the request scope is destroyed then it will
be automatically rolled back. This removes the need to explicitly catch exceptions and call <code>rollback</code>, and acts as a safety net
against inadvertent transaction leaks, however it does mean that this can only be used when the request scope is active. The second
example in the method calls begin with a timeout option, and then rolls back the transaction.</p>
</div>
<div class="paragraph">
<p>The second method shows the use of lambda scoped transactions with <code>QuarkusTransaction.runner(&#8230;&#8203;)</code>;
the first example just runs a <code>Runnable</code> within a new transaction,
the second does the same but joining the existing transaction (if any),
and the third calls a <code>Callable</code> with some specific options.
In particular the <code>exceptionHandler</code> method can be used to control if the transaction is rolled back or not on exception.</p>
</div>
<div class="paragraph">
<p>The following semantics are supported:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>QuarkusTransaction.disallowingExisting()</code>/<code>DISALLOW_EXISTING</code></dt>
<dd>
<p>If a transaction is already associated with the current thread a <code>QuarkusTransactionException</code> will be thrown,
otherwise a new transaction is started, and follows all the normal lifecycle rules.</p>
</dd>
<dt class="hdlist1"><code>QuarkusTransaction.joiningExisting()</code>/<code>JOIN_EXISTING</code></dt>
<dd>
<p>If no transaction is active then a new transaction will be started, and committed when the method ends.
If an exception is thrown the exception handler registered by <code>#exceptionHandler(Function)</code> will be called to
decide if the TX should be committed or rolled back.
If an existing transaction is active then the method is run in the context of the existing transaction. If an
exception is thrown the exception handler will be called, however
a result of <code>ExceptionResult#ROLLBACK</code> will result in the TX marked as rollback only, while a result of
<code>ExceptionResult#COMMIT</code> will result in no action being taken.</p>
</dd>
<dt class="hdlist1"><code>QuarkusTransaction.requiringNew()</code>/<code>REQUIRE_NEW</code></dt>
<dd>
<p>If an existing transaction is already associated with the current thread then the transaction is suspended,
then a new transaction is started which follows all the normal lifecycle rules,
and when it&#8217;s complete the original transaction is resumed.
Otherwise, a new transaction is started, and follows all the normal lifecycle rules.</p>
</dd>
<dt class="hdlist1"><code>QuarkusTransaction.suspendingExisting()</code>/<code>SUSPEND_EXISTING</code></dt>
<dd>
<p>If no transaction is active then these semantics are basically a no-op.
If a transaction is active then it is suspended, and resumed after the task is run.
The exception handler will never be consulted when these semantics are in use, specifying both an exception handler and
these semantics are considered an error.
These semantics allows for code to easily be run outside the scope of a transaction.</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="legacy-api-approach"><a class="anchor" href="#legacy-api-approach"></a>Legacy API approach</h3>
<div class="paragraph">
<p>The less easy way is to inject a <code>UserTransaction</code> and use the various transaction demarcation methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class SantaClausService {

    @Inject ChildDAO childDAO;
    @Inject SantaClausDAO santaDAO;
    @Inject UserTransaction transaction;

    public void getAGiftFromSanta(Child child, String giftDescription) {
        // some transaction work
        try {
            transaction.begin();
            Gift gift = childDAO.addToGiftList(child, giftDescription);
            santaDAO.addToSantaTodoList(gift);
            transaction.commit();
        }
        catch(SomeException e) {
            // do something on Tx failure
            transaction.rollback();
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You cannot use <code>UserTransaction</code> in a method having a transaction started by a <code>@Transactional</code> call.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuring-the-transaction-timeout"><a class="anchor" href="#configuring-the-transaction-timeout"></a>Configuring the transaction timeout</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can configure the default transaction timeout, the timeout that applies to all transactions managed by the transaction manager, via the property <code>quarkus.transaction-manager.default-transaction-timeout</code>, specified as a duration.</p>
</div>
<div class="paragraph">
<p>Unresolved directive in transaction.adoc - include::{includes}/duration-format-note.adoc[]</p>
</div>
<div class="paragraph">
<p>The default value is 60 seconds.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuring-transaction-node-name-identifier"><a class="anchor" href="#configuring-transaction-node-name-identifier"></a>Configuring transaction node name identifier</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Narayana, as the underlying transaction manager, has a concept of a unique node identifier.
This is important if you consider using XA transactions that involve multiple resources.</p>
</div>
<div class="paragraph">
<p>The node name identifier plays a crucial part in the identification of a transaction.
The node name identifier is forged into the transaction id when the transaction is created.
Based on the node name identifier, the transaction manager is capable of recognizing the XA transaction
counterparts created in database or JMS broker. The identifier makes possible for the transaction manager
to roll back the transaction counterparts during recovery.</p>
</div>
<div class="paragraph">
<p>The node name identifier needs to be unique per transaction manager deployment.
And the node identifier needs to be stable over the transaction manager restarts.</p>
</div>
<div class="paragraph">
<p>The node name identifier may be configured via the property <code>quarkus.transaction-manager.node-name</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transaction-scope"><a class="anchor" href="#transaction-scope"></a>Using <code>@TransactionScoped</code> to bind CDI beans to the transaction lifecycle</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can define beans that live for as long as a transaction,
and through CDI lifecycle events perform actions when a transaction starts and ends.</p>
</div>
<div class="paragraph">
<p>Just assign the transaction <a href="cdi#bean-scope">scope</a> to such beans using the <code>@TransactionScoped</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@TransactionScoped
public class MyTransactionScopedBean {

    // The bean's state is bound to a specific transaction,
    // and restored even after suspending then resuming the transaction.
    int myData;

    @PostConstruct
    void onBeginTransaction() {
        // This gets invoked after a transaction begins.
    }

    @PreDestroy
    void onBeforeEndTransaction() {
        // This gets invoked before a transaction ends (commit or rollback).
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, if you don&#8217;t necessarily need to hold state during the transaction,
and just want to react to transaction start/end events,
you can simply declare event listeners in a differently scoped bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class MyTransactionEventListeningBean {

    void onBeginTransaction(@Observes @Initialized(TransactionScoped.class) Object event) {
        // This gets invoked when a transaction begins.
    }

    void onBeforeEndTransaction(@Observes @BeforeDestroyed(TransactionScoped.class) Object event) {
        // This gets invoked before a transaction ends (commit or rollback).
    }

    void onAfterEndTransaction(@Observes @Destroyed(TransactionScoped.class) Object event) {
        // This gets invoked after a transaction ends (commit or rollback).
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>event</code> object represents the transaction ID, and defines <code>toString()</code>/<code>equals()</code>/<code>hashCode()</code> accordingly.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In listener methods, you can access more information about the transaction in progress by accessing the <code>TransactionManager</code>,
which is a CDI bean and can be <code>@Inject</code>ed.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuring-transaction-log-to-be-stored-in-a-datasource"><a class="anchor" href="#configuring-transaction-log-to-be-stored-in-a-datasource"></a>Configuring transaction log to be stored in a DataSource</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Narayana project has the capability to store the transaction logs into a JDBC Datasource; this should be our recommendation for users needing transaction recovery capabilities, especially when running in volatile containers.</p>
</div>
<div class="paragraph">
<p>To enable this capability, you need to set <code>quarkus.transaction-manager.object-store.type</code> to <code>jdbc</code> explicitly. Also, you can specify a datasource name to be used for the transaction log storage by setting <code>quarkus.transaction-manager.object-store.datasource</code>. It will use the default datasource configuration if not specified.</p>
</div>
<div class="paragraph">
<p>If you enable <code>quarkus.transaction-manager.object-store.create-table</code>, the transaction log table will be created automatically if it does not exist.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When enabling this capability, the transaction node identifier must be set through <code>quarkus.transaction-manager.node-name</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="why-always-having-a-transaction-manager"><a class="anchor" href="#why-always-having-a-transaction-manager"></a>Why always having a transaction manager?</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">Does it work everywhere I want to?</dt>
<dd>
<p>Yep, it works in your Quarkus application, in your IDE, in your tests, because all of these are Quarkus applications.
JTA has some bad press for some people.
I don&#8217;t know why.
Let&#8217;s just say that this is not your grandpa&#8217;s JTA implementation.
What we have is perfectly embeddable and lean.</p>
</dd>
<dt class="hdlist1">Does it do 2 Phase Commit and slow down my app?</dt>
<dd>
<p>No, this is an old folk tale.
Let&#8217;s assume it essentially comes for free and let you scale to more complex cases involving several datasources as needed.</p>
</dd>
<dt class="hdlist1">I don&#8217;t need transaction when I do read only operations, it&#8217;s faster.</dt>
<dd>
<p>Wrong.<br>
First off, just disable the transaction by marking your transaction boundary with <code>@Transactional(NOT_SUPPORTED)</code> (or <code>NEVER</code> or <code>SUPPORTS</code> depending on the semantic you want).<br>
Second, it&#8217;s again fairy tale that not using transaction is faster.
The answer is, it depends on your DB and how many SQL SELECTs you are making.
No transaction means the DB does have a single operation transaction context anyway.<br>
Third, when you do several SELECTs, it&#8217;s better to wrap them in a single transaction because they will all be consistent with one another.
Say your DB represents your car dashboard, you can see the number of kilometers remaining and the fuel gauge level.
By reading it in one transaction, they will be consistent.
If you read one and the other from two different transactions, then they can be inconsistent.
It can be more dramatic if you read data related to rights and access management for example.</p>
</dd>
<dt class="hdlist1">Why do you prefer JTA vs Hibernate&#8217;s transaction management API</dt>
<dd>
<p>Managing the transactions manually via <code>entityManager.getTransaction().begin()</code> and friends lead to a butt ugly code with tons of try catch finally that people get wrong.
Transactions are also about JMS and other database access, so one API makes more sense.</p>
</dd>
<dt class="hdlist1">It&#8217;s a mess because I don&#8217;t know if my Jakarta Persistence persistence unit is using <code>JTA</code> or <code>Resource-level</code> Transaction</dt>
<dd>
<p>It&#8217;s not a mess in Quarkus :)
Resource-level was introduced to support Jakarta Persistence in a non managed environment.
But Quarkus is both lean and a managed environment, so we can safely always assume we are in JTA mode.
The end result is that the difficulties of running Hibernate ORM + CDI + a transaction manager in Java SE mode are solved by Quarkus.</p>
</dd>
</dl>
</div>
</div>
</div>