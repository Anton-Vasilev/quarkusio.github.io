<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus allows different beans to interact using asynchronous events, thus promoting loose-coupling.
The messages are sent to <em>virtual addresses</em>.
It offers 3 types of delivery mechanism:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>point-to-point - send the message, one consumer receives it. If several consumers listen to the address, a round-robin is applied;</p>
</li>
<li>
<p>publish/subscribe - publish a message, all the consumers listening to the address are receiving the message;</p>
</li>
<li>
<p>request/reply - send the message and expect a response. The receiver can respond to the message in an asynchronous-fashion</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All these delivery mechanisms are non-blocking, and are providing one of the fundamental brick to build reactive applications.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The asynchronous message passing feature allows replying to messages which is not supported by Reactive Messaging.
However, it is limited to single-event behavior (no stream) and to local messages.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="installing"><a class="anchor" href="#installing"></a>Installing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This mechanism uses the Vert.x EventBus, so you need to enable the <code>vertx</code> extension to use this feature.
If you are creating a new project, set the <code>extensions</code> parameter are follows:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in reactive-event-bus.adoc - include::{includes}/devtools/create-app.adoc[]</p>
</div>
<div class="paragraph">
<p>If you have an already created project, the <code>vertx</code> extension can be added to an existing Quarkus project with
the <code>add-extension</code> command:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in reactive-event-bus.adoc - include::{includes}/devtools/extension-add.adoc[]</p>
</div>
<div class="paragraph">
<p>Otherwise, you can manually add this to the dependencies section of your build file:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-vertx&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-vertx")</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="consuming-events"><a class="anchor" href="#consuming-events"></a>Consuming events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To consume events, use the <code>io.quarkus.vertx.ConsumeEvent</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.vertx;

import io.quarkus.vertx.ConsumeEvent;

import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class GreetingService {

    @ConsumeEvent                           <i class="conum" data-value="1"></i><b>(1)</b>
    public String consume(String name) {    <i class="conum" data-value="2"></i><b>(2)</b>
        return name.toUpperCase();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If not set, the address is the fully qualified name of the bean, for instance, in this snippet it&#8217;s <code>org.acme.vertx.GreetingService</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The method parameter is the message body. If the method returns <em>something</em> it&#8217;s the message response.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>By default, the code consuming the event must be <em>non-blocking</em>, as it&#8217;s called on the Vert.x event loop.
If your processing is blocking, use the <code>blocking</code> attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConsumeEvent(value = "blocking-consumer", blocking = true)
void consumeBlocking(String message) {
    // Something blocking
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can annotate your method with <code>@io.smallrye.common.annotation.Blocking</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConsumeEvent(value = "blocking-consumer")
@Blocking
void consumeBlocking(String message) {
    // Something blocking
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When using <code>@Blocking</code>, it ignores the value of the <code>blocking</code> attribute of <code>@ConsumeEvent</code>.
See the <a href="quarkus-reactive-architecture">Quarkus Reactive Architecture documentation</a> for further details on this topic.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Asynchronous processing is also possible by returning either an <code>io.smallrye.mutiny.Uni</code> or a <code>java.util.concurrent.CompletionStage</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.vertx;

import io.quarkus.vertx.ConsumeEvent;

import jakarta.enterprise.context.ApplicationScoped;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;
import io.smallrye.mutiny.Uni;

@ApplicationScoped
public class GreetingService {

    @ConsumeEvent
    public CompletionStage&lt;String&gt; consume(String name) {
        // return a CompletionStage completed when the processing is finished.
        // You can also fail the CompletionStage explicitly
    }

    @ConsumeEvent
    public Uni&lt;String&gt; process(String name) {
        // return an Uni completed when the processing is finished.
        // You can also fail the Uni explicitly
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">Mutiny</div>
<div class="paragraph">
<p>The previous example uses Mutiny reactive types.
If you are not familiar with Mutiny, check <a href="mutiny-primer">Mutiny - an intuitive reactive programming library</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="configuring-the-address"><a class="anchor" href="#configuring-the-address"></a>Configuring the address</h3>
<div class="paragraph">
<p>The <code>@ConsumeEvent</code> annotation can be configured to set the address:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConsumeEvent("greeting")               <i class="conum" data-value="1"></i><b>(1)</b>
public String consume(String name) {
    return name.toUpperCase();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Receive the messages sent to the <code>greeting</code> address</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="replying"><a class="anchor" href="#replying"></a>Replying</h3>
<div class="paragraph">
<p>The <em>return</em> value of a method annotated with <code>@ConsumeEvent</code> is used as response to the incoming message.
For instance, in the following snippet, the returned <code>String</code> is the response.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConsumeEvent("greeting")
public String consume(String name) {
    return name.toUpperCase();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also return a <code>Uni&lt;T&gt;</code> or a <code>CompletionStage&lt;T&gt;</code> to handle asynchronous reply:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConsumeEvent("greeting")
public Uni&lt;String&gt; consume2(String name) {
    return Uni.createFrom().item(() -&gt; name.toUpperCase()).emitOn(executor);
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can inject an <code>executor</code> if you use the Context Propagation extension:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inject ManagedExecutor executor;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can use the default Quarkus worker pool using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Executor executor = Infrastructure.getDefaultWorkerPool();</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="implementing-fire-and-forget-interactions"><a class="anchor" href="#implementing-fire-and-forget-interactions"></a>Implementing fire and forget interactions</h3>
<div class="paragraph">
<p>You don&#8217;t have to reply to received messages.
Typically, for a <em>fire and forget</em> interaction, the messages are consumed and the sender does not need to know about it.
To implement this, your consumer method just returns <code>void</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConsumeEvent("greeting")
public void consume(String event) {
    // Do something with the event
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dealing-with-messages"><a class="anchor" href="#dealing-with-messages"></a>Dealing with messages</h3>
<div class="paragraph">
<p>As said above, this mechanism is based on the Vert.x event bus. So, you can also use <code>Message</code> directly:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ConsumeEvent("greeting")
public void consume(Message&lt;String&gt; msg) {
    System.out.println(msg.address());
    System.out.println(msg.body());
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="handling-failures"><a class="anchor" href="#handling-failures"></a>Handling Failures</h3>
<div class="paragraph">
<p>If a method annotated with <code>@ConsumeEvent</code> throws an exception then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>if a reply handler is set then the failure is propagated back to the sender via an <code>io.vertx.core.eventbus.ReplyException</code> with code <code>ConsumeEvent#FAILURE_CODE</code> and the exception message,</p>
</li>
<li>
<p>if no reply handler is set then the exception is rethrown (and wrapped in a <code>RuntimeException</code> if necessary) and can be handled by the default exception handler, i.e. <code>io.vertx.core.Vertx#exceptionHandler()</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sending-messages"><a class="anchor" href="#sending-messages"></a>Sending messages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ok, we have seen how to receive messages, let&#8217;s now switch to the <em>other side</em>: the sender.
Sending and publishing messages use the Vert.x event bus:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.vertx;

import io.smallrye.mutiny.Uni;
import io.vertx.mutiny.core.eventbus.EventBus;
import io.vertx.mutiny.core.eventbus.Message;

import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/async")
public class EventResource {

    @Inject
    EventBus bus;                                       <i class="conum" data-value="1"></i><b>(1)</b>

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("{name}")
    public Uni&lt;String&gt; greeting(String name) {
        return bus.&lt;String&gt;request("greeting", name)        <i class="conum" data-value="2"></i><b>(2)</b>
                .onItem().transform(Message::body);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inject the Event bus</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Send a message to the address <code>greeting</code>. Message payload is <code>name</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>EventBus</code> object provides methods to:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>send</code> a message to a specific address - one single consumer receives the message.</p>
</li>
<li>
<p><code>publish</code> a message to a specific address - all consumers receive the messages.</p>
</li>
<li>
<p><code>send</code> a message and expect reply asynchronously</p>
</li>
<li>
<p><code>send</code> a message and expect reply in a blocking manner</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Case 1
bus.&lt;String&gt;requestAndForget("greeting", name);
// Case 2
bus.publish("greeting", name);
// Case 3
Uni&lt;String&gt; response = bus.&lt;String&gt;request("address", "hello, how are you?")
        .onItem().transform(Message::body);
// Case 4
String response = bus.&lt;String&gt;requestAndAwait("greeting", name).body();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="putting-things-together-bridging-http-and-messages"><a class="anchor" href="#putting-things-together-bridging-http-and-messages"></a>Putting things together - bridging HTTP and messages</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s revisit a greeting HTTP endpoint and use asynchronous message passing to delegate the call to a separated bean.
It uses the request/reply dispatching mechanism.
Instead of implementing the business logic inside the Jakarta REST endpoint, we are sending a message.
This message is consumed by another bean and the response is sent using the <em>reply</em> mechanism.</p>
</div>
<div class="paragraph">
<p>First create a new project using:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in reactive-event-bus.adoc - include::{includes}/devtools/create-app.adoc[]</p>
</div>
<div class="paragraph">
<p>You can already start the application in <em>dev mode</em> using:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in reactive-event-bus.adoc - include::{includes}/devtools/dev.adoc[]</p>
</div>
<div class="paragraph">
<p>Then, creates a new Jakarta REST resource with the following content:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/org/acme/vertx/EventResource.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.vertx;

import io.smallrye.mutiny.Uni;
import io.vertx.mutiny.core.eventbus.EventBus;
import io.vertx.mutiny.core.eventbus.Message;

import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/async")
public class EventResource {

    @Inject
    EventBus bus;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    @Path("{name}")
    public Uni&lt;String&gt; greeting(String name) {
        return bus.&lt;String&gt;request("greeting", name)            <i class="conum" data-value="1"></i><b>(1)</b>
                .onItem().transform(Message::body);            <i class="conum" data-value="2"></i><b>(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>send the <code>name</code> to the <code>greeting</code> address and request a response</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>when we get the response, extract the body and send it to the user</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you call this endpoint, you will wait and get a timeout. Indeed, no one is listening.
So, we need a consumer listening on the <code>greeting</code> address. Create a <code>GreetingService</code> bean with the following content:</p>
</div>
<div class="listingblock">
<div class="title">src/main/java/org/acme/vertx/GreetingService.java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.vertx;

import io.quarkus.vertx.ConsumeEvent;

import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class GreetingService {

    @ConsumeEvent("greeting")
    public String greeting(String name) {
        return "Hello " + name;
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This bean receives the name, and returns the greeting message.</p>
</div>
<div class="paragraph">
<p>Now, open your browser to <a href="http://localhost:8080/async/Quarkus" class="bare">http://localhost:8080/async/Quarkus</a>, and you should see:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Hello Quarkus</code></pre>
</div>
</div>
<div class="paragraph">
<p>To better understand, let&#8217;s detail how the HTTP request/response has been handled:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>The request is received by the <code>hello</code> method</p>
</li>
<li>
<p>a message containing the <em>name</em> is sent to the event bus</p>
</li>
<li>
<p>Another bean receives this message and computes the response</p>
</li>
<li>
<p>This response is sent back using the reply mechanism</p>
</li>
<li>
<p>Once the reply is received by the sender, the content is written to the HTTP response</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This application can be packaged using:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in reactive-event-bus.adoc - include::{includes}/devtools/build.adoc[]</p>
</div>
<div class="paragraph">
<p>You can also compile it as a native executable with:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in reactive-event-bus.adoc - include::{includes}/devtools/build-native.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-codecs"><a class="anchor" href="#using-codecs"></a>Using codecs</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://vertx.io/docs/vertx-core/java/#event_bus">Vert.x Event Bus</a> uses codecs to <em>serialize</em> and <em>deserialize</em> objects.
Quarkus provides a default codec for local delivery.
So you can exchange objects as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GET
@Produces(MediaType.TEXT_PLAIN)
@Path("{name}")
public Uni&lt;String&gt; greeting(String name) {
    return bus.&lt;String&gt;request("greeting", new MyName(name))
        .onItem().transform(Message::body);
}

@ConsumeEvent(value = "greeting")
Uni&lt;String&gt; greeting(MyName name) {
    return Uni.createFrom().item(() -&gt; "Hello " + name.getName());
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to use a specific codec, you need to explicitly set it on both ends:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GET
@Produces(MediaType.TEXT_PLAIN)
@Path("{name}")
public Uni&lt;String&gt; greeting(String name) {
    return bus.&lt;String&gt;request("greeting", name,
        new DeliveryOptions().setCodecName(MyNameCodec.class.getName())) <i class="conum" data-value="1"></i><b>(1)</b>
        .onItem().transform(Message::body);
}

@ConsumeEvent(value = "greeting", codec = MyNameCodec.class)            <i class="conum" data-value="2"></i><b>(2)</b>
Uni&lt;String&gt; greeting(MyName name) {
    return Uni.createFrom().item(() -&gt; "Hello "+name.getName());
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the name of the codec to use to send the message</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Set the codec to use to receive the message</td>
</tr>
</table>
</div>
</div>
</div>