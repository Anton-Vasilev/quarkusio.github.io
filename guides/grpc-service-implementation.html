<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>gRPC service implementations exposed as CDI beans are automatically registered and served by quarkus-grpc.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Implementing a gRPC service requires the gRPC classes to be generated.
Place your <code>proto</code> files in <code>src/main/proto</code> and run <code>mvn compile</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="generated-code"><a class="anchor" href="#generated-code"></a>Generated Code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus generates a few implementation classes for services declared in the <code>proto</code> file:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A <em>service interface</em> using the Mutiny API</p>
<div class="ulist">
<ul>
<li>
<p>the class name is <code>${JAVA_PACKAGE}.${NAME_OF_THE_SERVICE}</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>An <em>implementation base</em> class using the gRPC API</p>
<div class="ulist">
<ul>
<li>
<p>the class name is structured as follows: <code>${JAVA_PACKAGE}.${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase</code></p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>For example, if you use the following <code>proto</code> file snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">option java_package = "hello"; <i class="conum" data-value="1"></i><b>(1)</b>

service Greeter { <i class="conum" data-value="2"></i><b>(2)</b>
    rpc SayHello (HelloRequest) returns (HelloReply) {}
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>hello</code> is the java package for the generated classes.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Greeter</code> is the service name.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Then the service interface is <code>hello.Greeter</code> and the implementation base is the abstract static nested class: <code>hello.GreeterGrpc.GreeterImplBase</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
You&#8217;ll need to implement the <em>service interface</em> or extend the <em>base class</em> with your service implementation bean as described in the following sections.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implementing-a-service-with-the-mutiny-api"><a class="anchor" href="#implementing-a-service-with-the-mutiny-api"></a>Implementing a Service with the Mutiny API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To implement a gRPC service using the Mutiny API, create a class that implements the service interface.
Then, implement the methods defined in the service interface.
If you don&#8217;t want to implement a service method just throw an <code>java.lang.UnsupportedOperationException</code> from the method body (the exception will be automatically converted to the appropriate gRPC exception).
Finally, implement the service and add the <code>@GrpcService</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.grpc.GrpcService;
import hello.Greeter;

@GrpcService <i class="conum" data-value="1"></i><b>(1)</b>
public class HelloService implements Greeter { <i class="conum" data-value="2"></i><b>(2)</b>

    @Override
    public Uni&lt;HelloReply&gt; sayHello(HelloRequest request) {
        return Uni.createFrom().item(() -&gt;
                HelloReply.newBuilder().setMessage("Hello " + request.getName()).build()
        );
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A gRPC service implementation bean must be annotated with the <code>@GrpcService</code> annotation and should not declare any other CDI qualifier. All gRPC services have the <code>jakarta.inject.Singleton</code> scope. Additionally, the request context is always active during a service call.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>hello.Greeter</code> is the generated service interface.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The service implementation bean can also extend the Mutiny implementation base, where the class name is structured as follows: <code>Mutiny${NAME_OF_THE_SERVICE}Grpc.${NAME_OF_THE_SERVICE}ImplBase</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="implementing-a-service-with-the-default-grpc-api"><a class="anchor" href="#implementing-a-service-with-the-default-grpc-api"></a>Implementing a Service with the default gRPC API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To implement a gRPC service using the default gRPC API, create a class that extends the default implementation base.
Then, override the methods defined in the service interface.
Finally, implement the service and add the <code>@GrpcService</code> annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.grpc.GrpcService;

@GrpcService
public class HelloService extends GreeterGrpc.GreeterImplBase {

    @Override
    public void sayHello(HelloRequest request, StreamObserver&lt;HelloReply&gt; responseObserver) {
        String name = request.getName();
        String message = "Hello " + name;
        responseObserver.onNext(HelloReply.newBuilder().setMessage(message).build());
        responseObserver.onCompleted();
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="blocking-service-implementation"><a class="anchor" href="#blocking-service-implementation"></a>Blocking Service Implementation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, all the methods from a gRPC service run on the event loop.
As a consequence, you must <strong>not</strong> block.
If your service logic must block, annotate the method with <code>io.smallrye.common.annotation.Blocking</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Override
@Blocking
public Uni&lt;HelloReply&gt; sayHelloBlocking(HelloRequest request) {
    // Do something blocking before returning the Uni
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="handling-streams"><a class="anchor" href="#handling-streams"></a>Handling Streams</h2>
<div class="sectionbody">
<div class="paragraph">
<p>gRPC allows receiving and returning streams:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">service Streaming {
    rpc Source(Empty) returns (stream Item) {} // Returns a stream
    rpc Sink(stream Item) returns (Empty) {}   // Reads a stream
    rpc Pipe(stream Item) returns (stream Item) {}  // Reads a streams and return a streams
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using Mutiny, you can implement these as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.grpc.GrpcService;

@GrpcService
public class StreamingService implements Streaming {

    @Override
    public Multi&lt;Item&gt; source(Empty request) {
        // Just returns a stream emitting an item every 2ms and stopping after 10 items.
        return Multi.createFrom().ticks().every(Duration.ofMillis(2))
                .select().first(10)
                .map(l -&gt; Item.newBuilder().setValue(Long.toString(l)).build());
    }

    @Override
    public Uni&lt;Empty&gt; sink(Multi&lt;Item&gt; request) {
        // Reads the incoming streams, consume all the items.
        return request
                .map(Item::getValue)
                .map(Long::parseLong)
                .collect().last()
                .map(l -&gt; Empty.newBuilder().build());
    }

    @Override
    public Multi&lt;Item&gt; pipe(Multi&lt;Item&gt; request) {
        // Reads the incoming stream, compute a sum and return the cumulative results
        // in the outbound stream.
        return request
                .map(Item::getValue)
                .map(Long::parseLong)
                .onItem().scan(() -&gt; 0L, Long::sum)
                .onItem().transform(l -&gt; Item.newBuilder().setValue(Long.toString(l)).build());
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="health"><a class="anchor" href="#health"></a>Health Check</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For the implemented services, Quarkus gRPC exposes health information in the following format:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-protobuf hljs" data-lang="protobuf">syntax = "proto3";

package grpc.health.v1;

message HealthCheckRequest {
  string service = 1;
}

message HealthCheckResponse {
  enum ServingStatus {
    UNKNOWN = 0;
    SERVING = 1;
    NOT_SERVING = 2;
  }
  ServingStatus status = 1;
}

service Health {
  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);

  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Clients can specify the fully qualified service name to get the health status of a specific service
or skip specifying the service name to get the general status of the gRPC server.</p>
</div>
<div class="paragraph">
<p>For more details, check out the
<a href="https://github.com/grpc/grpc/blob/v1.28.1/doc/health-checking.md">gRPC documentation</a></p>
</div>
<div class="paragraph">
<p>Additionally, if Quarkus SmallRye Health is added to the application, a readiness check for
the state of the gRPC services will be added to the MicroProfile Health endpoint response, that is <code>/q/health</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reflection-service"><a class="anchor" href="#reflection-service"></a>Reflection Service</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus gRPC Server implements the <a href="https://github.com/grpc/grpc/blob/master/doc/server-reflection.md">reflection service</a>.
This service allows tools like <a href="https://github.com/fullstorydev/grpcurl">grpcurl</a> or <a href="https://github.com/gusaul/grpcox">grpcox</a> to interact with your services.</p>
</div>
<div class="paragraph">
<p>The reflection service is enabled by default in <em>dev</em> mode.
In test or production mode, you need to enable it explicitly by setting <code>quarkus.grpc.server.enable-reflection-service</code> to <code>true</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Quarkus exposes both the reflection service <code>v1</code> and <code>v1alpha</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="scaling"><a class="anchor" href="#scaling"></a>Scaling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, quarkus-grpc starts a single gRPC server running on a single event loop.</p>
</div>
<div class="paragraph">
<p>If you wish to scale your server, you can set the number of server instances by setting <code>quarkus.grpc.server.instances</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="server-configuration"><a class="anchor" href="#server-configuration"></a>Server Configuration</h2>
<div class="sectionbody">
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When you disable <code>quarkus.grpc.server.use-separate-server</code>, you are then using the new Vert.x gRPC server implementation
which uses the existing HTTP server. Which means that the server port is now <code>8080</code> (or the port configured with <code>quarkus.http.port</code>).
Also, most of the other configuration properties are no longer applied, since it&#8217;s the HTTP server that should already be properly configured.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When you enable <code>quarkus.grpc.server.xds.enabled</code>, it&#8217;s the xDS that should handle most of the configuration above.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="example-of-configuration"><a class="anchor" href="#example-of-configuration"></a>Example of Configuration</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="enabling-tls"><a class="anchor" href="#enabling-tls"></a>Enabling TLS</h3>
<div class="paragraph">
<p>To enable TLS, use the following configuration.</p>
</div>
<div class="paragraph">
<p>Note that all paths in the configuration may either specify a resource on the classpath
(typically from <code>src/main/resources</code> or its subfolder) or an external file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.grpc.server.ssl.certificate=tls/server.pem
quarkus.grpc.server.ssl.key=tls/server.key</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When SSL/TLS is configured, <code>plain-text</code> is automatically disabled.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="tls-with-mutual-auth"><a class="anchor" href="#tls-with-mutual-auth"></a>TLS with Mutual Auth</h3>
<div class="paragraph">
<p>To use TLS with mutual authentication, use the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.grpc.server.ssl.certificate=tls/server.pem
quarkus.grpc.server.ssl.key=tls/server.key
quarkus.grpc.server.ssl.trust-store=tls/ca.jks
quarkus.grpc.server.ssl.trust-store-password=*****
quarkus.grpc.server.ssl.client-auth=REQUIRED</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="server-interceptors"><a class="anchor" href="#server-interceptors"></a>Server Interceptors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>gRPC server interceptors let you perform logic, such as authentication, before your service is invoked.</p>
</div>
<div class="paragraph">
<p>You can implement a gRPC server interceptor by creating an <code>@ApplicationScoped</code> bean implementing <code>io.grpc.ServerInterceptor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
// add @GlobalInterceptor for interceptors meant to be invoked for every service
public class MyInterceptor implements ServerInterceptor {

    @Override
    public &lt;ReqT, RespT&gt; ServerCall.Listener&lt;ReqT&gt; interceptCall(ServerCall&lt;ReqT, RespT&gt; serverCall,
            Metadata metadata, ServerCallHandler&lt;ReqT, RespT&gt; serverCallHandler) {
        // ...
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Check the <a href="https://grpc.github.io/grpc-java/javadoc/io/grpc/ServerInterceptor.html">ServerInterceptor JavaDoc</a> to properly implement your interceptor.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To apply an interceptor to all exposed services, annotate it with <code>@io.quarkus.grpc.GlobalInterceptor</code>.
To apply an interceptor to a single service, register it on the service with <code>@io.quarkus.grpc.RegisterInterceptor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.grpc.GrpcService;
import io.quarkus.grpc.RegisterInterceptor;

@GrpcService
@RegisterInterceptor(MyInterceptor.class)
public class StreamingService implements Streaming {
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you have multiple server interceptors, you can order them by implementing the <code>jakarta.enterprise.inject.spi.Prioritized</code> interface. Please note that all the global interceptors are invoked before the service-specific
interceptors.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class MyInterceptor implements ServerInterceptor, Prioritized {

    @Override
    public &lt;ReqT, RespT&gt; ServerCall.Listener&lt;ReqT&gt; interceptCall(ServerCall&lt;ReqT, RespT&gt; serverCall,
            Metadata metadata, ServerCallHandler&lt;ReqT, RespT&gt; serverCallHandler) {
        // ...
    }

    @Override
    public int getPriority() {
        return 10;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interceptors with the highest priority are called first.
The default priority, used if the interceptor does not implement the <code>Prioritized</code> interface, is <code>0</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing-your-services"><a class="anchor" href="#testing-your-services"></a>Testing your services</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The easiest way to test a gRPC service is to use a gRPC client as described
in <a href="grpc-service-consumption">Consuming a gRPC Service</a>.</p>
</div>
<div class="paragraph">
<p>Please note that in the case of using a client to test an exposed service that does not use TLS,
there is no need to provide any configuration. E.g. to test the <code>HelloService</code>
defined above, one could create the following test:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class HelloServiceTest implements Greeter {

    @GrpcClient
    Greeter client;

    @Test
    void shouldReturnHello() {
        CompletableFuture&lt;String&gt; message = new CompletableFuture&lt;&gt;();
        client.sayHello(HelloRequest.newBuilder().setName("Quarkus").build())
                .subscribe().with(reply -&gt; message.complete(reply.getMessage()));
        assertThat(message.get(5, TimeUnit.SECONDS)).isEqualTo("Hello Quarkus");
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="trying-out-your-services-manually"><a class="anchor" href="#trying-out-your-services-manually"></a>Trying out your services manually</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the dev mode, you can try out your gRPC services in the Quarkus Dev UI.
Just go to <a href="http://localhost:8080/q/dev-v1" class="bare">http://localhost:8080/q/dev-v1</a> and click on <em>Services</em> under the gRPC tile.</p>
</div>
<div class="paragraph">
<p>Please note that your application needs to expose the "normal" HTTP port for the Dev UI to be accessible. If your application does not expose any HTTP endpoints, you can create a dedicated profile with a dependency on <code>quarkus-vertx-http</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    &lt;profiles&gt;
        &lt;profile&gt;
            &lt;id&gt;development&lt;/id&gt;
            &lt;dependencies&gt;
                &lt;dependency&gt;
                    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
                    &lt;artifactId&gt;quarkus-vertx-http&lt;/artifactId&gt;
                &lt;/dependency&gt;
            &lt;/dependencies&gt;
        &lt;/profiles&gt;
    &lt;/profile&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Having it, you can run the dev mode with: <code>mvn quarkus:dev -Pdevelopment</code>.</p>
</div>
<div class="paragraph">
<p>If you use Gradle, you can simply add a dependency for the <code>quarkusDev</code> task:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">dependencies {
    quarkusDev 'io.quarkus:quarkus-vertx-http'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="grpc-server-metrics"><a class="anchor" href="#grpc-server-metrics"></a>gRPC Server metrics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="enabling-metrics-collection"><a class="anchor" href="#enabling-metrics-collection"></a>Enabling metrics collection</h3>
<div class="paragraph">
<p>gRPC server metrics are automatically enabled when the application also uses the <a href="telemetry-micrometer"><code>quarkus-micrometer</code></a> extension.
Micrometer collects the metrics of all the gRPC services implemented by the application.</p>
</div>
<div class="paragraph">
<p>As an example, if you export the metrics to Prometheus, you will get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text"># HELP grpc_server_responses_sent_messages_total The total number of responses sent
# TYPE grpc_server_responses_sent_messages_total counter
grpc_server_responses_sent_messages_total{method="SayHello",methodType="UNARY",service="helloworld.Greeter",} 6.0
# HELP grpc_server_processing_duration_seconds The total time taken for the server to complete the call
# TYPE grpc_server_processing_duration_seconds summary
grpc_server_processing_duration_seconds_count{method="SayHello",methodType="UNARY",service="helloworld.Greeter",statusCode="OK",} 6.0
grpc_server_processing_duration_seconds_sum{method="SayHello",methodType="UNARY",service="helloworld.Greeter",statusCode="OK",} 0.016216771
# HELP grpc_server_processing_duration_seconds_max The total time taken for the server to complete the call
# TYPE grpc_server_processing_duration_seconds_max gauge
grpc_server_processing_duration_seconds_max{method="SayHello",methodType="UNARY",service="helloworld.Greeter",statusCode="OK",} 0.007985236
# HELP grpc_server_requests_received_messages_total The total number of requests received
# TYPE grpc_server_requests_received_messages_total counter
grpc_server_requests_received_messages_total{method="SayHello",methodType="UNARY",service="helloworld.Greeter",} 6.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The service name, method and type can be found in the <em>tags</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="disabling-metrics-collection"><a class="anchor" href="#disabling-metrics-collection"></a>Disabling metrics collection</h3>
<div class="paragraph">
<p>To disable the gRPC server metrics when <code>quarkus-micrometer</code> is used, add the following property to the application configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.micrometer.binder.grpc-server.enabled=false</code></pre>
</div>
</div>
</div>
</div>
</div>