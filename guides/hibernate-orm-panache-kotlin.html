<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Hibernate ORM is the de facto standard Jakarta Persistence (formerly known as JPA) implementation and is well-known in the Java ecosystem. Hibernate ORM with Panache offers a
new layer atop this familiar framework.  This guide will not dive in to the specifics of either as those are already
covered in the <a href="hibernate-orm-panache">Hibernate ORM with Panache guide</a>.  In this guide, we&#8217;ll cover the Kotlin specific changes
needed to use Hibernate ORM with Panache in your Kotlin-based Quarkus applications.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the kotlin version of Hibernate ORM with Panache, note that the <code>PanacheEntity</code>, <code>PanacheQuery</code> and <code>PanacheRepository</code> are in a different package: <code>io.quarkus.hibernate.orm.panache.kotlin</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="first-an-example"><a class="anchor" href="#first-an-example"></a>First: an example</h2>
<div class="sectionbody">
<div class="paragraph">
<p>As we saw in the Hibernate with Panache guide, it allows us to extend the functionality in our entities and repositories (also known as DAOs) with some automatically
provided functionality.  When using Kotlin, the approach is very similar to what we see in the Java version with a slight
change or two.  To Panache-enable your entity, you would define it something like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Entity
class Person: PanacheEntity() {
    lateinit var name: String
    lateinit var birth: LocalDate
    lateinit var status: Status
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see our entities remain simple.  There is, however, a slight difference from the Java version.  The Kotlin
language doesn&#8217;t support the notion of static methods in quite the same way as Java does.  Instead, we must use a
<a href="https://kotlinlang.org/docs/tutorials/kotlin-for-py/objects-and-companion-objects.html#companion-objects">companion object</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Entity
class Person : PanacheEntity() {
    companion object: PanacheCompanion&lt;Person&gt; {  <i class="conum" data-value="1"></i><b>(1)</b>
        fun findByName(name: String) = find("name", name).firstResult()
        fun findAlive() = list("status", Status.Alive)
        fun deleteStefs() = delete("name", "Stef")
    }

    lateinit var name: String  <i class="conum" data-value="2"></i><b>(2)</b>
    lateinit var birth: LocalDate
    lateinit var status: Status
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The companion object holds all the methods not related to a specific instance allowing for general management and
querying bound to a specific type.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here there are options, but we&#8217;ve chosen the <code>lateinit</code> approach.  This allows us to declare these fields as non-null
knowing they will be properly assigned either by the constructor (not shown) or by hibernate loading data from the
database.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These types differ from the Java types mentioned in those tutorials.  For Kotlin support, all the Panache
types will be found in the <code>io.quarkus.hibernate.orm.panache.kotlin</code> package.  This subpackage allows for the distinction
between the Java and Kotlin variants and allows for both to be used unambiguously in a single project.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the Kotlin version, we&#8217;ve simply moved the bulk of the <a href="https://www.martinfowler.com/eaaCatalog/activeRecord.html"><code>active record pattern</code></a>
functionality to the <code>companion object</code>.  Apart from this slight change, we can then work with our types in ways that map easily
from the Java side of world.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="solution"><a class="anchor" href="#solution"></a>Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We recommend that you follow the instructions in the next sections and create the application step by step.
However, you can go right to the completed example.</p>
</div>
<div class="paragraph">
<p>Clone the Git repository: <code>git clone <a href="https://github.com/quarkusio/quarkus-quickstarts.git" class="bare">https://github.com/quarkusio/quarkus-quickstarts.git</a></code>, or download an <a href="https://github.com/quarkusio/quarkus-quickstarts/archive/main.zip">archive</a>.</p>
</div>
<div class="paragraph">
<p>The solution is located in the <code>hibernate-orm-panache-kotlin-quickstart</code> <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/hibernate-orm-panache-kotlin-quickstart">directory</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting-up-and-configuring-hibernate-orm-with-panache-and-kotlin"><a class="anchor" href="#setting-up-and-configuring-hibernate-orm-with-panache-and-kotlin"></a>Setting up and configuring Hibernate ORM with Panache and Kotlin</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To get started using Hibernate ORM with Panache and Kotlin, you can, generally, follow the steps laid out in the Java tutorial. The biggest
change to configuring your project is the Quarkus artifact to include.  You can, of course, keep the Java version if you
need but if all you need are the Kotlin APIs then include the following dependency instead:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-hibernate-orm-panache-kotlin&lt;/artifactId&gt;  <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note the addition of <code>-kotlin</code> on the end. Generally you&#8217;ll only need this version but if your project will be using
both Java and Kotlin code, you can safely include both artifacts.</td>
</tr>
</table>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-hibernate-orm-panache-kotlin") <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Note the addition of <code>-kotlin</code> on the end. Generally you&#8217;ll only need this version but if your project will be using
both Java and Kotlin code, you can safely include both artifacts.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="using-the-repository-pattern"><a class="anchor" href="#using-the-repository-pattern"></a>Using the repository pattern</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="defining-your-entity"><a class="anchor" href="#defining-your-entity"></a>Defining your entity</h3>
<div class="paragraph">
<p>When using the repository pattern, you can define your entities as regular Jakarta Persistence entities.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Entity
class Person {
    @Id
    @GeneratedValue
    var id: Long? = null;
    lateinit var name: String
    lateinit var birth: LocalDate
    lateinit var status: Status
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="defining-your-repository"><a class="anchor" href="#defining-your-repository"></a>Defining your repository</h3>
<div class="paragraph">
<p>When using Repositories, you get the exact same convenient methods as with the active record pattern, injected in your Repository,
by making them implement <code>PanacheRepository</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@ApplicationScoped
class PersonRepository: PanacheRepository&lt;Person&gt; {
     fun findByName(name: String) = find("name", name).firstResult()
     fun findAlive() = list("status", Status.Alive)
     fun deleteStefs() = delete("name", "Stef")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All the operations that are defined on <code>PanacheEntityBase</code> are available on your repository, so using it
is exactly the same as using the active record pattern, except you need to inject it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">@Inject
lateinit var personRepository: PersonRepository

@GET
fun count() = personRepository.count()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="most-useful-operations"><a class="anchor" href="#most-useful-operations"></a>Most useful operations</h3>
<div class="paragraph">
<p>Once you have written your repository, here are the most common operations you will be able to perform:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">// creating a person
var person = Person()
person.name = "Stef"
person.birth = LocalDate.of(1910, Month.FEBRUARY, 1)
person.status = Status.Alive

// persist it
personRepository.persist(person)

// note that once persisted, you don't need to explicitly save your entity: all
// modifications are automatically persisted on transaction commit.

// check if it's persistent
if(personRepository.isPersistent(person)){
    // delete it
    personRepository.delete(person)
}

// getting a list of all Person entities
val allPersons = personRepository.listAll()

// finding a specific person by ID
person = personRepository.findById(personId) ?: throw Exception("No person with that ID")

// finding all living persons
val livingPersons = personRepository.list("status", Status.Alive)

// counting all persons
val countAll = personRepository.count()

// counting all living persons
val countAlive = personRepository.count("status", Status.Alive)

// delete all living persons
personRepository.delete("status", Status.Alive)

// delete all persons
personRepository.deleteAll()

// delete by id
val deleted = personRepository.deleteById(personId)

// set the name of all living persons to 'Mortal'
personRepository.update("name = 'Mortal' where status = ?1", Status.Alive)</code></pre>
</div>
</div>
<div class="paragraph">
<p>All <code>list</code> methods have equivalent <code>stream</code> versions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-kotlin hljs" data-lang="kotlin">val persons = personRepository.streamAll();
val namesButEmmanuels = persons
    .map { it.name.toLowerCase() }
    .filter { it != "emmanuel" }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>stream</code> methods require a transaction to work.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For more examples, please consult the <a href="hibernate-orm-panache">Java version</a> for complete details.  Both APIs
are the same and work identically except for some Kotlin-specific tweaks to make things feel more natural to
Kotlin developers.  These tweaks include things like better use of nullability and the lack of <code>Optional</code> on API
methods.</p>
</div>
</div>
</div>
</div>