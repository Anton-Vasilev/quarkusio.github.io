<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>gRPC clients can be injected in your application code.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Consuming gRPC services requires the gRPC classes to be generated.
Place your <code>proto</code> files in <code>src/main/proto</code> and run <code>mvn compile</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stubs-and-injection"><a class="anchor" href="#stubs-and-injection"></a>Stubs and Injection</h2>
<div class="sectionbody">
<div class="paragraph">
<p>gRPC generation provides several stubs, providing different ways to consume a gRPC service.
You can inject:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a service interface using the Mutiny API,</p>
</li>
<li>
<p>a blocking stub using the gRPC API,</p>
</li>
<li>
<p>a reactive stub based on Mutiny,</p>
</li>
<li>
<p>the gRPC <code>io.grpc.Channel</code>, that lets you create other types of stubs.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.grpc.GrpcClient;

import hello.Greeter;
import hello.GreeterGrpc.GreeterBlockingStub;
import hello.MutinyGreeterGrpc.MutinyGreeterStub;

class MyBean {

   // A service interface using the Mutiny API
   @GrpcClient("helloService")                   <i class="conum" data-value="1"></i><b>(1)</b>
   Greeter greeter;

   // A reactive stub based on Mutiny
   @GrpcClient("helloService")
   MutinyGreeterGrpc.MutinyGreeterStub mutiny;

   // A blocking stub using the gRPC API
   @GrpcClient
   GreeterGrpc.GreeterBlockingStub helloService; <i class="conum" data-value="2"></i><b>(2)</b>

   @GrpcClient("hello-service")
   Channel channel;

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>A gRPC client injection point must be annotated with the <code>@GrpcClient</code> qualifier. This qualifier can be used to specify the name that is used to configure the underlying gRPC client. For example, if you set it to <code>hello-service</code>, configuring the host of the service is done using the <code>quarkus.grpc.clients.<strong>hello-service</strong>.host</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If the name is not specified via the <code>GrpcClient#value()</code> then the field name is used instead, e.g. <code>helloService</code> in this particular case.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The stub class names are derived from the service name used in your <code>proto</code> file.
For example, if you use <code>Greeter</code> as a service name as in:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">option java_package = "hello";

service Greeter {
    rpc SayHello (HelloRequest) returns (HelloReply) {}
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the service interface name is: <code>hello.Greeter</code>, the Mutiny stub name is: <code>hello.MutinyGreeterGrpc.MutinyGreeterStub</code> and the blocking stub name is: <code>hello.GreeterGrpc.GreeterBlockingStub</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="service-interface"><a class="anchor" href="#service-interface"></a>Service Interface</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.grpc.GrpcClient;
import io.smallrye.mutiny.Uni;

import hello.Greeter;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/hello")
public class ExampleResource {

   @GrpcClient <i class="conum" data-value="1"></i><b>(1)</b>
   Greeter hello;

   @GET
   @Path("/mutiny/{name}")
   public Uni&lt;String&gt; helloMutiny(String name) {
      return hello.sayHello(HelloRequest.newBuilder().setName(name).build())
            .onItem().transform(HelloReply::getMessage);
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The service name is derived from the injection point - the field name is used. The <code>quarkus.grpc.clients.hello.host</code> property must be set.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="blocking-stub"><a class="anchor" href="#blocking-stub"></a>Blocking Stub</h3>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.grpc.GrpcClient;

import hello.GreeterGrpc.GreeterBlockingStub;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/hello")
public class ExampleResource {

   @GrpcClient("hello") <i class="conum" data-value="1"></i><b>(1)</b>
   GreeterGrpc.GreeterBlockingStub blockingHelloService;

   @GET
   @Path("/blocking/{name}")
   public String helloBlocking(String name) {
      return blockingHelloService.sayHello(HelloRequest.newBuilder().setName(name).build()).getMessage();
   }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>quarkus.grpc.clients.hello.host</code> property must be set.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="handling-streams"><a class="anchor" href="#handling-streams"></a>Handling streams</h3>
<div class="paragraph">
<p>gRPC allows sending and receiving streams:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">service Streaming {
    rpc Source(Empty) returns (stream Item) {} // Returns a stream
    rpc Sink(stream Item) returns (Empty) {}   // Reads a stream
    rpc Pipe(stream Item) returns (stream Item) {}  // Reads a streams and return a streams
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the Mutiny stub, you can interact with these as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.grpc.example.streaming;

import io.grpc.examples.streaming.Empty;
import io.grpc.examples.streaming.Item;
import io.grpc.examples.streaming.MutinyStreamingGrpc;
import io.quarkus.grpc.GrpcClient;

import io.smallrye.mutiny.Multi;
import io.smallrye.mutiny.Uni;

import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/streaming")
@Produces(MediaType.APPLICATION_JSON)
public class StreamingEndpoint {

    @GrpcClient
    MutinyStreamingGrpc.MutinyStreamingStub streaming;

    @GET
    public Multi&lt;String&gt; invokeSource() {
        // Retrieve a stream
        return streaming.source(Empty.newBuilder().build())
                .onItem().transform(Item::getValue);
    }

    @GET
    @Path("sink/{max}")
    public Uni&lt;Void&gt; invokeSink(int max) {
        // Send a stream and wait for completion
        Multi&lt;Item&gt; inputs = Multi.createFrom().range(0, max)
                .map(i -&gt; Integer.toString(i))
                .map(i -&gt; Item.newBuilder().setValue(i).build());
        return streaming.sink(inputs).onItem().ignore().andContinueWithNull();
    }

    @GET
    @Path("/{max}")
    public Multi&lt;String&gt; invokePipe(int max) {
        // Send a stream and retrieve a stream
        Multi&lt;Item&gt; inputs = Multi.createFrom().range(0, max)
                .map(i -&gt; Integer.toString(i))
                .map(i -&gt; Item.newBuilder().setValue(i).build());
        return streaming.pipe(inputs).onItem().transform(Item::getValue);
    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="client-configuration"><a class="anchor" href="#client-configuration"></a>Client configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For each gRPC service you inject in your application, you can configure the following attributes:</p>
</div>
<div class="paragraph">
<p>The <code>client-name</code> is the name set in the <code>@GrpcClient</code> or derived from the injection point if not explicitly defined.</p>
</div>
<div class="paragraph">
<p>The following examples uses <em>hello</em> as the client name.
Don&#8217;t forget to replace it with the name you used in the <code>@GrpcClient</code> annotation.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When you enable <code>quarkus.grpc.clients."client-name".use-quarkus-grpc-client</code>, you are then using the new Vert.x gRPC channel implementation, so not all configuration properties can still be applied. And currently there is no Stork support yet.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
When you enable <code>quarkus.grpc.clients."client-name".xds.enabled</code>, it&#8217;s the xDS that should handle most of the configuration above.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="enabling-tls"><a class="anchor" href="#enabling-tls"></a>Enabling TLS</h3>
<div class="paragraph">
<p>To enable TLS, use the following configuration.
Note that all paths in the configuration may either specify a resource on the classpath
(typically from <code>src/main/resources</code> or its subfolder) or an external file.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.grpc.clients.hello.host=localhost

# either a path to a classpath resource or to a file:
quarkus.grpc.clients.hello.ssl.trust-store=tls/ca.pem</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When SSL/TLS is configured, <code>plain-text</code> is automatically disabled.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="tls-with-mutual-auth"><a class="anchor" href="#tls-with-mutual-auth"></a>TLS with Mutual Auth</h3>
<div class="paragraph">
<p>To use TLS with mutual authentication, use the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.grpc.clients.hello.host=localhost
quarkus.grpc.clients.hello.plain-text=false

# all the following may use either a path to a classpath resource or to a file:
quarkus.grpc.clients.hello.ssl.certificate=tls/client.pem
quarkus.grpc.clients.hello.ssl.key=tls/client.key
quarkus.grpc.clients.hello.ssl.trust-store=tls/ca.pem</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="client-stub-deadlines"><a class="anchor" href="#client-stub-deadlines"></a>Client Stub Deadlines</h3>
<div class="paragraph">
<p>If you need to configure a deadline for a gRPC stub, i.e. to specify a duration of time after which the stub will always return the status error <code>DEADLINE_EXCEEDED</code>.
You can specify the deadline via the <code>quarkus.grpc.clients."service-name".deadline</code> configuration property, e.g.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.grpc.clients.hello.host=localhost
quarkus.grpc.clients.hello.deadline=2s <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Set the  deadline for all injected stubs.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Do not use this feature to implement an RPC timeout.
To implement an RPC timeout, either use Mutiny <code>call.ifNoItem().after(&#8230;&#8203;)</code> or Fault Tolerance <code>@Timeout</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="grpc-headers"><a class="anchor" href="#grpc-headers"></a>gRPC Headers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Similarly to HTTP, alongside the message, gRPC calls can carry headers.
Headers can be useful e.g. for authentication.</p>
</div>
<div class="paragraph">
<p>To set headers for a gRPC call, create a client with headers attached and then perform the call on this client:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.enterprise.context.ApplicationScoped;

import examples.Greeter;
import examples.HelloReply;
import examples.HelloRequest;
import io.grpc.Metadata;
import io.quarkus.grpc.GrpcClient;
import io.quarkus.grpc.GrpcClientUtils;
import io.smallrye.mutiny.Uni;

@ApplicationScoped
public class MyService {
    @GrpcClient
    Greeter client;

    public Uni&lt;HelloReply&gt; doTheCall() {
        Metadata extraHeaders = new Metadata();
        if (headers) {
            extraHeaders.put("my-header", "my-interface-value");
        }

        Greeter alteredClient = GrpcClientUtils.attachHeaders(client, extraHeaders); <i class="conum" data-value="1"></i><b>(1)</b>

        return alteredClient.sayHello(HelloRequest.newBuilder().setName(name).build()); <i class="conum" data-value="2"></i><b>(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Alter the client to make calls with the <code>extraHeaders</code> attached</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Perform the call with the altered client. The original client remains unmodified</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>GrpcClientUtils</code> work with all flavors of clients.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="client-interceptors"><a class="anchor" href="#client-interceptors"></a>Client Interceptors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A gRPC client interceptor can be implemented by a CDI bean that also implements the <code>io.grpc.ClientInterceptor</code> interface.
You can annotate an injected client with <code>@io.quarkus.grpc.RegisterClientInterceptor</code> to register the specified interceptor for the particular client instance.
The <code>@RegisterClientInterceptor</code> annotation is repeatable.
Alternatively, if you want to apply the interceptor to any injected client then annotate the interceptor bean with <code>@io.quarkus.grpc.GlobalInterceptor</code>.</p>
</div>
<div class="listingblock">
<div class="title">Global Client Interceptor Example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.grpc.GlobalInterceptor;

import io.grpc.ClientInterceptor;

@GlobalInterceptor <i class="conum" data-value="1"></i><b>(1)</b>
@ApplicationScoped
public class MyInterceptor implements ClientInterceptor {

    @Override
    public &lt;ReqT, RespT&gt; ClientCall&lt;ReqT, RespT&gt; interceptCall(MethodDescriptor&lt;ReqT, RespT&gt; method,
            CallOptions callOptions, Channel next) {
       // ...
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This interceptor is applied to all injected gRPC clients.</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Check the <a href="https://grpc.github.io/grpc-java/javadoc/io/grpc/ClientInterceptor.html">ClientInterceptor JavaDoc</a> to properly implement your interceptor.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="title"><code>@RegisterClientInterceptor</code> Example</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.grpc.GrpcClient;
import io.quarkus.grpc.RegisterClientInterceptor;

import hello.Greeter;

@ApplicationScoped
class MyBean {

    @RegisterClientInterceptor(MySpecialInterceptor.class) <i class="conum" data-value="1"></i><b>(1)</b>
    @GrpcClient("helloService")
    Greeter greeter;
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Registers the <code>MySpecialInterceptor</code> for this particular client.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When you have multiple client interceptors, you can order them by implementing the <code>jakarta.enterprise.inject.spi.Prioritized</code> interface:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class MyInterceptor implements ClientInterceptor, Prioritized {

    @Override
    public &lt;ReqT, RespT&gt; ClientCall&lt;ReqT, RespT&gt; interceptCall(MethodDescriptor&lt;ReqT, RespT&gt; method,
            CallOptions callOptions, Channel next) {
       // ...
    }

    @Override
    public int getPriority() {
        return 10;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interceptors with the highest priority are called first.
The default priority, used if the interceptor does not implement the <code>Prioritized</code> interface, is <code>0</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="grpc-client-metrics"><a class="anchor" href="#grpc-client-metrics"></a>gRPC Client metrics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="enabling-metrics-collection"><a class="anchor" href="#enabling-metrics-collection"></a>Enabling metrics collection</h3>
<div class="paragraph">
<p>gRPC client metrics are automatically enabled when the application also uses the <a href="telemetry-micrometer"><code>quarkus-micrometer</code></a> extension.
Micrometer collects the metrics of all the gRPC clients used by the application.</p>
</div>
<div class="paragraph">
<p>As an example, if you export the metrics to Prometheus, you will get:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text"># HELP grpc_client_responses_received_messages_total The total number of responses received
# TYPE grpc_client_responses_received_messages_total counter
grpc_client_responses_received_messages_total{method="SayHello",methodType="UNARY",service="helloworld.Greeter",} 6.0
# HELP grpc_client_requests_sent_messages_total The total number of requests sent
# TYPE grpc_client_requests_sent_messages_total counter
grpc_client_requests_sent_messages_total{method="SayHello",methodType="UNARY",service="helloworld.Greeter",} 6.0
# HELP grpc_client_processing_duration_seconds The total time taken for the client to complete the call, including network delay
# TYPE grpc_client_processing_duration_seconds summary
grpc_client_processing_duration_seconds_count{method="SayHello",methodType="UNARY",service="helloworld.Greeter",statusCode="OK",} 6.0
grpc_client_processing_duration_seconds_sum{method="SayHello",methodType="UNARY",service="helloworld.Greeter",statusCode="OK",} 0.167411625
# HELP grpc_client_processing_duration_seconds_max The total time taken for the client to complete the call, including network delay
# TYPE grpc_client_processing_duration_seconds_max gauge
grpc_client_processing_duration_seconds_max{method="SayHello",methodType="UNARY",service="helloworld.Greeter",statusCode="OK",} 0.136478028</code></pre>
</div>
</div>
<div class="paragraph">
<p>The service name, method and type can be found in the <em>tags</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="disabling-metrics-collection"><a class="anchor" href="#disabling-metrics-collection"></a>Disabling metrics collection</h3>
<div class="paragraph">
<p>To disable the gRPC client metrics when <code>quarkus-micrometer</code> is used, add the following property to the application configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.micrometer.binder.grpc-client.enabled=false</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="custom-exception-handling"><a class="anchor" href="#custom-exception-handling"></a>Custom exception handling</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If any of the gRPC services or server interceptors throw an (custom) exception, you can add your own <a href="https://github.com/quarkusio/quarkus/extensions/grpc/api/src/main/java/io/quarkus/grpc/ExceptionHandlerProvider.java">ExceptionHandlerProvider</a>
as a CDI bean in your application, to provide a custom handling of those exceptions.</p>
</div>
<div class="paragraph">
<p>e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class HelloExceptionHandlerProvider implements ExceptionHandlerProvider {
    @Override
    public &lt;ReqT, RespT&gt; ExceptionHandler&lt;ReqT, RespT&gt; createHandler(ServerCall.Listener&lt;ReqT&gt; listener,
            ServerCall&lt;ReqT, RespT&gt; serverCall, Metadata metadata) {
        return new HelloExceptionHandler&lt;&gt;(listener, serverCall, metadata);
    }

    @Override
    public Throwable transform(Throwable t) {
        if (t instanceof HelloException he) {
            return new StatusRuntimeException(Status.ABORTED.withDescription(he.getName()));
        } else {
            return ExceptionHandlerProvider.toStatusException(t, true);
        }
    }

    private static class HelloExceptionHandler&lt;A, B&gt; extends ExceptionHandler&lt;A, B&gt; {
        public HelloExceptionHandler(ServerCall.Listener&lt;A&gt; listener, ServerCall&lt;A, B&gt; call, Metadata metadata) {
            super(listener, call, metadata);
        }

        @Override
        protected void handleException(Throwable t, ServerCall&lt;A, B&gt; call, Metadata metadata) {
            StatusRuntimeException sre = (StatusRuntimeException) ExceptionHandlerProvider.toStatusException(t, true);
            Metadata trailers = sre.getTrailers() != null ? sre.getTrailers() : metadata;
            call.close(sre.getStatus(), trailers);
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dev-mode"><a class="anchor" href="#dev-mode"></a>Dev Mode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, when starting the application in dev mode, a gRPC server is started, even if no services are configured.
You can configure the gRPC extension&#8217;s dev mode behavior using the following properties.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="inject-mock-clients"><a class="anchor" href="#inject-mock-clients"></a>Inject mock clients</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In your <code>@QuarkusTest</code>, you can use <code>@InjectMock</code> to inject the Mutiny client of a gRPC service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@QuarkusTest
public class GrpcMockTest {

    @InjectMock
    @GrpcClient("hello")
    Greeter greeter;

    @Test
    void test1() {
        HelloRequest request = HelloRequest.newBuilder().setName("neo").build();
        Mockito.when(greeter.sayHello(Mockito.any(HelloRequest.class)))
                .thenReturn(Uni.createFrom().item(HelloReply.newBuilder().setMessage("hello neo").build()));
        Assertions.assertEquals(greeter.sayHello(request).await().indefinitely().getMessage(), "hello neo");
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Only the Mutiny client can be <em>mocked</em>, channels, and other stubs cannot be mocked.
</td>
</tr>
</table>
</div>
</div>
</div>