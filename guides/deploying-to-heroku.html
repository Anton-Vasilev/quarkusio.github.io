<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>In this guide you will learn how to deploy a Quarkus based web application as a web-dyno to Heroku.</p>
</div>
<div class="paragraph">
<p>This guide covers:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Update Quarkus HTTP Port</p>
</li>
<li>
<p>Install the Heroku CLI</p>
</li>
<li>
<p>Deploy the application to Heroku</p>
</li>
<li>
<p>Deploy the application as Docker image to Heroku</p>
</li>
<li>
<p>Deploy the native application as Docker image to Heroku</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="prerequisites"><a class="anchor" href="#prerequisites"></a>Prerequisites</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unresolved directive in deploying-to-heroku.adoc - include::{includes}/prerequisites.adoc[]
* <a href="https://www.heroku.com/">A Heroku Account</a>. Free accounts work.
* <a href="https://devcenter.heroku.com/articles/heroku-cli">Heroku CLI installed</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Heroku is a platform as a service (PaaS) that enables developers to build, run, and operate applications entirely in the cloud.
It supports several languages like Java, Ruby, Node.js, Scala, Clojure, Python, PHP, and Go.
In addition, it offers a container registry that can be used to deploy prebuilt container images.</p>
</div>
<div class="paragraph">
<p>Heroku can be used in different ways to run a Quarkus application:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>As a plain Java program running in a container defined by Heroku&#8217;s environment</p>
</li>
<li>
<p>As a containerized Java program running in a container defined by the Quarkus build process</p>
</li>
<li>
<p>As a containerized native program running in a container defined by the Quarkus build process</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All three approaches need to be aware of the port that Heroku assigns to it to handle traffic.
Luckily, there&#8217;s a dynamic configuration property for it.</p>
</div>
<div class="paragraph">
<p>The guide assumes that you have the <a href="https://devcenter.heroku.com/articles/heroku-cli">Heroku CLI</a> installed.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="common-project-setup"><a class="anchor" href="#common-project-setup"></a>Common project setup</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This guide will take as input an application developed in the <a href="getting-started">Getting Started guide</a>.</p>
</div>
<div class="paragraph">
<p>Make sure you have the getting-started application at hand, or clone the Git repository: <code>git clone <a href="https://github.com/quarkusio/quarkus-quickstarts.git" class="bare">https://github.com/quarkusio/quarkus-quickstarts.git</a></code>,
or download an <a href="https://github.com/quarkusio/quarkus-quickstarts/archive/main.zip">archive</a>. The solution is located in the <code>getting-started</code> directory.</p>
</div>
<div class="paragraph">
<p>Heroku can react on changes in your repository, run CI and redeploy your application when your code changes.
Therefore, we start with a valid repository already.</p>
</div>
<div class="paragraph">
<p>Also, make sure your Heroku CLI is working:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">heroku --version
heroku login</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="prepare-the-quarkus-http-port"><a class="anchor" href="#prepare-the-quarkus-http-port"></a>Prepare the Quarkus HTTP Port</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Heroku picks a random port and assigns it to the container that is eventually running your Quarkus application.
That port is available as an environment variable under <code>$PORT</code>.
The easiest way to make Quarkus in all deployment scenarios aware of it is using the following configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.http.port=${PORT:8080}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This reads as: "Listen on <code>$PORT</code> if this is a defined variable, otherwise listen on 8080 as usual."
Run the following to add this to your <code>application.properties</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">echo "quarkus.http.port=\${PORT:8080}" &gt;&gt; src/main/resources/application.properties
git commit -am "Configure the HTTP Port."</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deploy-the-repository-and-build-on-heroku"><a class="anchor" href="#deploy-the-repository-and-build-on-heroku"></a>Deploy the repository and build on Heroku</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The first variant uses the Quarkus Maven build to create the <em>quarkus-app</em> application structure containing the runnable "fast-jar" as well as all libraries needed
inside Heroku&#8217;s build infrastructure and then deploying that result, the other one uses a local build process to create an optimized container.</p>
</div>
<div class="paragraph">
<p>Two additional files are needed in your application&#8217;s root directory:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>system.properties</code> to configure the Java version</p>
</li>
<li>
<p><code>Procfile</code> to configure how Heroku starts your application</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Quarkus needs JDK 11, so we specify that first:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">echo "java.runtime.version=11" &gt;&gt; system.properties
git add system.properties
git commit -am "Configure the Java version for Heroku."</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will deploy a web application so we need to configure the type <code>web</code> in the Heroku <code>Procfile</code> like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">echo "web: java \$JAVA_OPTS -jar target/quarkus-app/quarkus-run.jar" &gt;&gt; Procfile
git add Procfile
git commit -am "Add a Procfile."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Your application should already be runnable via <code>heroku local web</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create an application in your account and deploy that repository to it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">heroku create
git push heroku master
heroku open</code></pre>
</div>
</div>
<div class="paragraph">
<p>The application will have a generated name and the terminal should output that. <code>heroku open</code> opens your default browser to access your new application.</p>
</div>
<div class="paragraph">
<p>To access the REST endpoint via curl, run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">APP_NAME=`heroku info | grep  "=== .*" |sed "s/=== //"`
curl $APP_NAME.herokuapp.com/hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, you can use the Heroku CLI to connect this repo to your GitHub account, too, but this is out of scope for this guide.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deploy-as-container"><a class="anchor" href="#deploy-as-container"></a>Deploy as container</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The advantage of pushing a whole container is that we are in complete control over its content and maybe even choose to deploy a container with a native executable running on GraalVM.</p>
</div>
<div class="paragraph">
<p>First, login to Heroku&#8217;s container registry:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">heroku container:login</code></pre>
</div>
</div>
<div class="paragraph">
<p>We need to add an extension to our project to build container images via the Quarkus Maven plugin:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">mvn quarkus:add-extension -Dextensions="container-image-docker"
git add pom.xml
git commit -am "Add container-image-docker extension."</code></pre>
</div>
</div>
<div class="paragraph">
<p>The image we are going to build needs to be named accordingly to work with Heroku&#8217;s registry and deployment.
We get the generated name via <code>heroku info</code> and pass it on to the (local) build:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">APP_NAME=`heroku info | grep  "=== .*" |sed "s/=== //"`
mvn clean package\
  -Dquarkus.container-image.build=true\
  -Dquarkus.container-image.group=registry.heroku.com/$APP_NAME\
  -Dquarkus.container-image.name=web\
  -Dquarkus.container-image.tag=latest</code></pre>
</div>
</div>
<div class="paragraph">
<p>With Docker installed, you can now push the image and release it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker push registry.heroku.com/$APP_NAME/web
heroku container:release web --app $APP_NAME</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can and should check the logs to see if your application is now indeed running from the container:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">heroku logs --app $APP_NAME --tail</code></pre>
</div>
</div>
<div class="paragraph">
<p>The initial push is rather big, as all layers of the image need to be transferred.
The following pushes will be smaller.</p>
</div>
<div class="paragraph">
<p>The biggest advantage we take when deploying our app as a container is to deploy a container with the natively compiled application.
Why? Because Heroku will stop or sleep the application when there&#8217;s no incoming traffic.
A native application will wake up much faster from its sleep.</p>
</div>
<div class="paragraph">
<p>The process is pretty much the same.
We opt in to compiling a native image inside a local container, so that we don&#8217;t have to deal with installing GraalVM locally:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">APP_NAME=`heroku info | grep  "=== .*" |sed "s/=== //"`
mvn clean package\
  -Dquarkus.container-image.build=true\
  -Dquarkus.container-image.group=registry.heroku.com/$APP_NAME\
  -Dquarkus.container-image.name=web\
  -Dquarkus.container-image.tag=latest\
  -Dnative\
  -Dquarkus.native.container-build=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>After that, push and release again:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker push registry.heroku.com/$APP_NAME/web
heroku container:release web --app $APP_NAME</code></pre>
</div>
</div>
</div>
</div>