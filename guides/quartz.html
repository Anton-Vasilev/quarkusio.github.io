<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Modern applications often need to run specific tasks periodically.
In this guide, you learn how to schedule periodic clustered tasks using the <a href="http://www.quartz-scheduler.org/">Quartz</a> extension.</p>
</div>
<div class="paragraph">
<p>Unresolved directive in quartz.adoc - include::{includes}/extension-status.adoc[]</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
If you only need to run in-memory scheduler use the <a href="scheduler">Scheduler</a> extension.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="prerequisites"><a class="anchor" href="#prerequisites"></a>Prerequisites</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unresolved directive in quartz.adoc - include::{includes}/prerequisites.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architecture"><a class="anchor" href="#architecture"></a>Architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this guide, we are going to expose one Rest API <code>tasks</code> to visualise the list of tasks created by a Quartz job running every 10 seconds.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="solution"><a class="anchor" href="#solution"></a>Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We recommend that you follow the instructions in the next sections and create the application step by step.
However, you can go right to the completed example.</p>
</div>
<div class="paragraph">
<p>Clone the Git repository: <code>git clone <a href="https://github.com/quarkusio/quarkus-quickstarts.git" class="bare">https://github.com/quarkusio/quarkus-quickstarts.git</a></code>, or download an <a href="https://github.com/quarkusio/quarkus-quickstarts/archive/main.zip">archive</a>.</p>
</div>
<div class="paragraph">
<p>The solution is located in the <code>quartz-quickstart</code> <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/quartz-quickstart">directory</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-the-maven-project"><a class="anchor" href="#creating-the-maven-project"></a>Creating the Maven project</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First, we need a new project. Create a new project with the following command:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in quartz.adoc - include::{includes}/devtools/create-app.adoc[]</p>
</div>
<div class="paragraph">
<p>It generates:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the Maven structure</p>
</li>
<li>
<p>a landing page accessible on <code><a href="http://localhost:8080" class="bare">http://localhost:8080</a></code></p>
</li>
<li>
<p>example <code>Dockerfile</code> files for both <code>native</code> and <code>jvm</code> modes</p>
</li>
<li>
<p>the application configuration file</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Maven project also imports the Quarkus Quartz extension.</p>
</div>
<div class="paragraph">
<p>If you already have your Quarkus project configured, you can add the <code>quartz</code> extension
to your project by running the following command in your project base directory:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in quartz.adoc - include::{includes}/devtools/extension-add.adoc[]</p>
</div>
<div class="paragraph">
<p>This will add the following to your build file:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-quartz&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-quartz")</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>To use a JDBC store, the <code>quarkus-agroal</code> extension, which provides the datasource support, is also required.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-the-task-entity"><a class="anchor" href="#creating-the-task-entity"></a>Creating the Task Entity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the <code>org.acme.quartz</code> package, create the <code>Task</code> class, with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.quartz;

import jakarta.persistence.Entity;
import java.time.Instant;
import jakarta.persistence.Table;

import io.quarkus.hibernate.orm.panache.PanacheEntity;

@Entity
@Table(name="TASKS")
public class Task extends PanacheEntity { <i class="conum" data-value="1"></i><b>(1)</b>
    public Instant createdAt;

    public Task() {
        createdAt = Instant.now();
    }

    public Task(Instant time) {
        this.createdAt = time;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare the entity using <a href="hibernate-orm-panache">Panache</a></td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-a-scheduled-job"><a class="anchor" href="#creating-a-scheduled-job"></a>Creating a scheduled job</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the <code>org.acme.quartz</code> package, create the <code>TaskBean</code> class, with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.quartz;

import jakarta.enterprise.context.ApplicationScoped;

import jakarta.transaction.Transactional;

import io.quarkus.scheduler.Scheduled;

@ApplicationScoped <i class="conum" data-value="1"></i><b>(1)</b>
public class TaskBean {

    @Transactional
    @Scheduled(every = "10s", identity = "task-job") <i class="conum" data-value="2"></i><b>(2)</b>
    void schedule() {
        Task task = new Task(); <i class="conum" data-value="3"></i><b>(3)</b>
        task.persist(); <i class="conum" data-value="4"></i><b>(4)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Declare the bean in the <em>application</em> scope</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use the <code>@Scheduled</code> annotation to instruct Quarkus to run this method every 10 seconds and set the unique identifier for this job.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Create a new <code>Task</code> with the current start time.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Persist the task in database using <a href="hibernate-orm-panache">Panache</a>.</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="scheduling-jobs-programmatically"><a class="anchor" href="#scheduling-jobs-programmatically"></a>Scheduling Jobs Programmatically</h3>
<div class="paragraph">
<p>An injected <code>io.quarkus.scheduler.Scheduler</code> can be used to <a href="scheduler-reference#programmatic_scheduling">schedule a job programmatically</a>.
However, it is also possible to leverage the Quartz API directly.
You can inject the underlying <code>org.quartz.Scheduler</code> in any bean:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.quartz;

@ApplicationScoped
public class TaskBean {

    @Inject
    org.quartz.Scheduler quartz; <i class="conum" data-value="1"></i><b>(1)</b>

    void onStart(@Observes StartupEvent event) throws SchedulerException {
       JobDetail job = JobBuilder.newJob(MyJob.class)
                         .withIdentity("myJob", "myGroup")
                         .build();
       Trigger trigger = TriggerBuilder.newTrigger()
                            .withIdentity("myTrigger", "myGroup")
                            .startNow()
                            .withSchedule(
                               SimpleScheduleBuilder.simpleSchedule()
                                  .withIntervalInSeconds(10)
                                  .repeatForever())
                            .build();
       quartz.scheduleJob(job, trigger); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    @Transactional
    void performTask() {
        Task task = new Task();
        task.persist();
    }

    // A new instance of MyJob is created by Quartz for every job execution
    public static class MyJob implements Job {

       @Inject
       TaskBean taskBean;

       public void execute(JobExecutionContext context) throws JobExecutionException {
          taskBean.performTask(); <i class="conum" data-value="3"></i><b>(3)</b>
       }

    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Inject the underlying <code>org.quartz.Scheduler</code> instance.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Schedule a new job using the Quartz API.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Invoke the <code>TaskBean#performTask()</code> method from the job. Jobs are also <a href="cdi">container-managed</a> beans if they belong to a <a href="cdi-reference">bean archive</a>.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By default, the scheduler is not started unless a <code>@Scheduled</code> business method is found. You may need to force the start of the scheduler for "pure" programmatic scheduling. See also <a href="#quartz-configuration-reference">Quartz Configuration Reference</a>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="updating-the-application-configuration-file"><a class="anchor" href="#updating-the-application-configuration-file"></a>Updating the application configuration file</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Edit the <code>application.properties</code> file and add the below configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Quartz configuration
quarkus.quartz.clustered=true <i class="conum" data-value="1"></i><b>(1)</b>
quarkus.quartz.store-type=jdbc-cmt <i class="conum" data-value="2"></i><b>(2)</b>
quarkus.quartz.misfire-policy.task-job=ignore-misfire-policy <i class="conum" data-value="3"></i><b>(3)</b>

# Datasource configuration.
quarkus.datasource.db-kind=postgresql
quarkus.datasource.username=quarkus_test
quarkus.datasource.password=quarkus_test
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost/quarkus_test

# Hibernate configuration
quarkus.hibernate-orm.database.generation=none
quarkus.hibernate-orm.log.sql=true
quarkus.hibernate-orm.sql-load-script=no-file

# flyway configuration
quarkus.flyway.connect-retries=10
quarkus.flyway.table=flyway_quarkus_history
quarkus.flyway.migrate-at-start=true
quarkus.flyway.baseline-on-migrate=true
quarkus.flyway.baseline-version=1.0
quarkus.flyway.baseline-description=Quartz</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Indicate that the scheduler will be run in clustered mode</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Use the database store to persist job related information so that they can be shared between nodes</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The misfire policy can be configured for each job. <code>task-job</code> is the identity of the job.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Valid misfire policy for cron jobs are: <code>smart-policy</code>, <code>ignore-misfire-policy</code>, <code>fire-now</code> and <code>cron-trigger-do-nothing</code>.
Valid misfire policy for interval jobs are: <code>smart-policy</code>, <code>ignore-misfire-policy</code>, <code>fire-now</code>, <code>simple-trigger-reschedule-now-with-existing-repeat-count</code>, <code>simple-trigger-reschedule-now-with-remaining-repeat-count</code>, <code>simple-trigger-reschedule-next-with-existing-count</code> and <code>simple-trigger-reschedule-next-with-remaining-count</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-a-rest-resource-and-a-test"><a class="anchor" href="#creating-a-rest-resource-and-a-test"></a>Creating a REST resource and a test</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create the <code>org.acme.quartz.TaskResource</code> class with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.quartz;

import java.util.List;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

@Path("/tasks")
public class TaskResource {

    @GET
    public List&lt;Task&gt; listAll() {
        return Task.listAll(); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Retrieve the list of created tasks from the database</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>You also have the option to create a <code>org.acme.quartz.TaskResourceTest</code> test with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.quartz;

import io.quarkus.test.junit.QuarkusTest;

import static org.hamcrest.Matchers.greaterThanOrEqualTo;

import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.is;

@QuarkusTest
public class TaskResourceTest {

    @Test
    public void tasks() throws InterruptedException {
        Thread.sleep(1000); // wait at least a second to have the first task created
        given()
                .when().get("/tasks")
                .then()
                .statusCode(200)
                .body("size()", is(greaterThanOrEqualTo(1))); <i class="conum" data-value="1"></i><b>(1)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Ensure that we have a <code>200</code> response and at least one task created</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-quartz-tables"><a class="anchor" href="#creating-quartz-tables"></a>Creating Quartz Tables</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Add a SQL migration file named <code>src/main/resources/db/migration/V2.0.0__QuarkusQuartzTasks.sql</code> with the content copied from
file with the content from <a href="https://github.com/quarkusio/quarkus-quickstarts/blob/main/quartz-quickstart/src/main/resources/db/migration/V2.0.0__QuarkusQuartzTasks.sql">V2.0.0__QuarkusQuartzTasks.sql</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuring-the-load-balancer"><a class="anchor" href="#configuring-the-load-balancer"></a>Configuring the load balancer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the root directory, create a <code>nginx.conf</code> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-conf hljs" data-lang="conf">user  nginx;

events {
    worker_connections   1000;
}

http {
        server {
              listen 8080;
              location / {
                proxy_pass http://tasks:8080; <i class="conum" data-value="1"></i><b>(1)</b>
              }
        }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Route all traffic to our tasks application</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting-application-deployment"><a class="anchor" href="#setting-application-deployment"></a>Setting Application Deployment</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the root directory, create a <code>docker-compose.yml</code> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">version: '3'

services:
  tasks: <i class="conum" data-value="1"></i><b>(1)</b>
    image: quarkus-quickstarts/quartz:1.0
    build:
      context: ./
      dockerfile: src/main/docker/Dockerfile.${QUARKUS_MODE:-jvm}
    environment:
      QUARKUS_DATASOURCE_URL: jdbc:postgresql://postgres/quarkus_test
    networks:
      - tasks-network
    depends_on:
      - postgres

  nginx: <i class="conum" data-value="2"></i><b>(2)</b>
    image: nginx:1.17.6
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on:
      - tasks
    ports:
      - 8080:8080
    networks:
      - tasks-network

  postgres: <i class="conum" data-value="3"></i><b>(3)</b>
    image: postgres:14.1
    container_name: quarkus_test
    environment:
      - POSTGRES_USER=quarkus_test
      - POSTGRES_PASSWORD=quarkus_test
      - POSTGRES_DB=quarkus_test
    ports:
      - 5432:5432
    networks:
      - tasks-network

networks:
  tasks-network:
    driver: bridge</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Define the tasks service</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Define the nginx load balancer to route incoming traffic to an appropriate node</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Define the configuration to run the database</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="running-the-database"><a class="anchor" href="#running-the-database"></a>Running the database</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In a separate terminal, run the below command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker-compose up postgres <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Start the database instance using the configuration options supplied in the <code>docker-compose.yml</code> file</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="run-the-application-in-dev-mode"><a class="anchor" href="#run-the-application-in-dev-mode"></a>Run the application in Dev Mode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Run the application with:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in quartz.adoc - include::{includes}/devtools/dev.adoc[]</p>
</div>
<div class="paragraph">
<p>After a few seconds, open another terminal and run <code>curl localhost:8080/tasks</code> to verify that we have at least one task created.</p>
</div>
<div class="paragraph">
<p>As usual, the application can be packaged using:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in quartz.adoc - include::{includes}/devtools/build.adoc[]</p>
</div>
<div class="paragraph">
<p>and executed with <code>java -jar target/quarkus-app/quarkus-run.jar</code>.</p>
</div>
<div class="paragraph">
<p>You can also generate the native executable with:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in quartz.adoc - include::{includes}/devtools/build-native.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="packaging-the-application-and-run-several-instances"><a class="anchor" href="#packaging-the-application-and-run-several-instances"></a>Packaging the application and run several instances</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The application can be packaged using:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in quartz.adoc - include::{includes}/devtools/build.adoc[]</p>
</div>
<div class="paragraph">
<p>Once the build is successful, run the below command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker-compose up --scale tasks=2 --scale nginx=1 <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Start two instances of the application and a load balancer</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After a few seconds, in another terminal, run <code>curl localhost:8080/tasks</code> to verify that tasks were only created at different instants and in an interval of 10 seconds.</p>
</div>
<div class="paragraph">
<p>You can also generate the native executable with:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in quartz.adoc - include::{includes}/devtools/build-native.adoc[]</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
It&#8217;s the responsibility of the deployer to clear/remove the previous state, i.e. stale jobs and triggers. Moreover, the applications that form the "Quartz cluster" should be identical, otherwise an unpredictable result may occur.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quartz-configure-instance-id"><a class="anchor" href="#quartz-configure-instance-id"></a>Configuring the Instance ID</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, the scheduler is configured with a simple instance ID generator using the machine hostname and the current timestamp, so you don&#8217;t need to worry about setting a appropriate <code>instance-id</code> for each node when running in clustered mode. However, you can define a specific <code>instance-id</code> by yourself setting a configuration property reference or using other generators.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.quartz.instance-id=${HOST:AUTO} <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This will expand the <code>HOST</code> environment variable and use <code>AUTO</code> as the default value if <code>HOST</code> is not set.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The example below configure the generator <code>org.quartz.simpl.HostnameInstanceIdGenerator</code> named as <code>hostname</code>, so you can use its name as <code>instance-id</code> to be used. That generator uses just the machine hostname and can be appropriate in environments providing unique names for the nodes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.quartz.instance-id=hostname
quarkus.quartz.instance-id-generators.hostname.class=org.quartz.simpl.HostnameInstanceIdGenerator</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
It&#8217;s the responsibility of the deployer to define appropriate instance identifiers. Moreover, the applications that form the "Quartz cluster" should contain unique instance identifiers, otherwise an unpredictable result may occur. It&#8217;s recommended to use an appropriate instance ID generator rather than specifying explicit identifiers.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quartz-register-plugin-listeners"><a class="anchor" href="#quartz-register-plugin-listeners"></a>Registering Plugin and Listeners</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can register <code>plugins</code>, <code>job-listeners</code> and <code>trigger-listeners</code> through Quarkus configuration.</p>
</div>
<div class="paragraph">
<p>The example below registers the plugin <code>org.quartz.plugins.history.LoggingJobHistoryPlugin</code> named as <code>jobHistory</code> with the property <code>jobSuccessMessage</code> defined as <code>Job [{1}.{0}] execution complete and reports: {8}</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.quartz.plugins.jobHistory.class=org.quartz.plugins.history.LoggingJobHistoryPlugin
quarkus.quartz.plugins.jobHistory.properties.jobSuccessMessage=Job [{1}.{0}] execution complete and reports: {8}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also register a listener programmatically with an injected <code>org.quartz.Scheduler</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyListenerManager {
    void onStart(@Observes StartupEvent event, org.quartz.Scheduler scheduler) throws SchedulerException {
        scheduler.getListenerManager().addJobListener(new MyJogListener());
        scheduler.getListenerManager().addTriggerListener(new MyTriggerListener());
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="quartz-configuration-reference"><a class="anchor" href="#quartz-configuration-reference"></a>Quartz Configuration Reference</h2>
<div class="sectionbody">

</div>
</div>