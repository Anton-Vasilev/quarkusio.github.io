<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Unresolved directive in _attributes.adoc - include::_attributes-local.adoc[]</p>
</div>
<div class="paragraph">
<p>This guide explains how to use Stork with Kubernetes for service discovery and load balancing.</p>
</div>
<div class="paragraph">
<p>If you are new to Stork, please read the <a href="stork">Stork Getting Started Guide</a>.</p>
</div>
<div class="paragraph">
<p>Unresolved directive in stork-kubernetes.adoc - include::{includes}/extension-status.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="prerequisites"><a class="anchor" href="#prerequisites"></a>Prerequisites</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unresolved directive in stork-kubernetes.adoc - include::{includes}/prerequisites.adoc[]
* Access to a Kubernetes cluster (Minikube is a viable option)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architecture"><a class="anchor" href="#architecture"></a>Architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this guide, we will work with a few components deployed in a Kubernetes cluster:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A simple blue service.</p>
</li>
<li>
<p>A simple red service.</p>
</li>
<li>
<p>The <code>color-service</code> is the Kubernetes service which is the entry point to the Blue and Red instances.</p>
</li>
<li>
<p>A client service using a REST client to call the blue or the red service. Service discovery and selection are delegated to Stork.</p>
</li>
</ul>
</div>
<div class="imageblock text-center">
<div class="content">
<img src="stork-kubernetes-architecture.png" alt="Architecture of the application" width="100%">
</div>
</div>
<div class="paragraph">
<p>For the sake of simplicity, everything will be deployed in the same namespace of the Kubernetes cluster.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="solution"><a class="anchor" href="#solution"></a>Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We recommend that you follow the instructions in the next sections and create the applications step by step.
However, you can go right to the completed example.</p>
</div>
<div class="paragraph">
<p>Clone the Git repository: <code>git clone <a href="https://github.com/quarkusio/quarkus-quickstarts.git" class="bare">https://github.com/quarkusio/quarkus-quickstarts.git</a></code>, or download an <a href="https://github.com/quarkusio/quarkus-quickstarts/archive/main.zip">archive</a>.</p>
</div>
<div class="paragraph">
<p>The solution is located in the <code>stork-kubernetes-quickstart</code> <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/stork-kubernetes-quickstart">directory</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="discovery-and-selection"><a class="anchor" href="#discovery-and-selection"></a>Discovery and selection</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Before going further, we need to discuss discovery vs. selection.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Service discovery is the process of locating service instances.
It produces a list of service instances that is potentially empty (if no service matches the request) or contains multiple service instances.</p>
</li>
<li>
<p>Service selection, also called load-balancing, chooses the best instance from the list returned by the discovery process.
The result is a single service instance or an exception when no suitable instance can be found.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Stork handles both discovery and selection.
However, it does not handle the communication with the service but only provides a service instance.
The various integrations in Quarkus extract the location of the service from that service instance.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bootstrapping-the-project"><a class="anchor" href="#bootstrapping-the-project"></a>Bootstrapping the project</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Create a Quarkus project importing the quarkus-rest-client-reactive and quarkus-resteasy-reactive extensions using your favorite approach:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in stork-kubernetes.adoc - include::{includes}/devtools/create-app.adoc[]</p>
</div>
<div class="paragraph">
<p>In the generated project, also add the following dependencies:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;
    &lt;artifactId&gt;stork-service-discovery-kubernetes&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
      &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;
      &lt;artifactId&gt;stork-load-balancer-random&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-kubernetes&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-kubernetes-client&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-container-image-jib&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.smallrye.stork:stork-service-discovery-kubernetes")
implementation("io.smallrye.stork:stork-load-balancer-random")
implementation("io.quarkus:quarkus-kubernetes")
implementation("io.quarkus:quarkus-kubernetes-client")
implementation("io.quarkus:quarkus-container-image-jib")</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>stork-service-discovery-kubernetes</code> provides an implementation of service discovery for Kubernetes. <code>stork-load-balancer-random</code> provides an implementation of random load balancer. <code>quarkus-kubernetes</code> enables the generation of Kubernetes manifests each time we perform a build. The <code>quarkuks-kubernetes-client</code> extension enables the use of the Fabric8 Kubernetes Client in native mode. And <code>quarkus-container-image-jib</code> enables the build of a container image using <a href="https://github.com/GoogleContainerTools/jib">Jib</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-blue-and-red-services"><a class="anchor" href="#the-blue-and-red-services"></a>The Blue and Red services</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s start with the very beginning: the service we will discover, select and call.</p>
</div>
<div class="paragraph">
<p>The Red and Blue are two simple REST services serving an endpoint responding <code>Hello from Red!</code> and <code>Hello from Blue!</code> respectively. The code of both applications has been developed following the <a href="https://quarkus.io/guides/getting-started">Getting Started Guide</a>.</p>
</div>
<div class="paragraph">
<p>As the goal of this guide is to show how to use Stork Kubernetes service discovery, we won&#8217;t provide the specifics steps for the Red and Blue services. Their container images are already built and available in a public registry:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://quay.io/repository/quarkus/blue-service">Blue service container image</a></p>
</li>
<li>
<p><a href="https://quay.io/repository/quarkus/red-service">Red service container image</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deploy-the-blue-and-red-services-in-kubernetes"><a class="anchor" href="#deploy-the-blue-and-red-services-in-kubernetes"></a>Deploy the Blue and Red services in Kubernetes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now that we have our service container images available in a public registry, we need to deploy them into the Kubernetes cluster.</p>
</div>
<div class="paragraph">
<p>The following file contains all the Kubernetes resources needed to deploy the Blue and Red services in the cluster and make them accessible:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: development
  name: endpoints-reader
rules:
  - apiGroups: [""] # "" indicates the core API group
    resources: ["endpoints", "pods"]
    verbs: ["get", "list"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: stork-rb
  namespace: development
subjects:
  - kind: ServiceAccount
    # Reference to upper's `metadata.name`
    name: default
    # Reference to upper's `metadata.namespace`
    namespace: development
roleRef:
  kind: Role
  name: endpoints-reader
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: v1
kind: Service
metadata:
  annotations:
    app.quarkus.io/commit-id: f747f359406bedfb1a39c57392a5b5a9eaefec56
    app.quarkus.io/build-timestamp: 2022-03-31 - 10:36:56 +0000
  labels:
    app.kubernetes.io/name: color-service
    app.kubernetes.io/version: "1.0"
  name: color-service <i class="conum" data-value="1"></i><b>(1)</b>
spec:
  ports:
    - name: http
      port: 80
      targetPort: 8080
  selector:
    app.kubernetes.io/version: "1.0"
    type: color-service
  type: ClusterIP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    app.quarkus.io/commit-id: f747f359406bedfb1a39c57392a5b5a9eaefec56
    app.quarkus.io/build-timestamp: 2022-03-31 - 10:36:56 +0000
  labels:
    color: blue
    type: color-service
    app.kubernetes.io/name: blue-service
    app.kubernetes.io/version: "1.0"
  name: blue-service <i class="conum" data-value="2"></i><b>(2)</b>
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: blue-service
      app.kubernetes.io/version: "1.0"
  template:
    metadata:
      annotations:
        app.quarkus.io/commit-id: f747f359406bedfb1a39c57392a5b5a9eaefec56
        app.quarkus.io/build-timestamp: 2022-03-31 - 10:36:56 +0000
      labels:
        color: blue
        type: color-service
        app.kubernetes.io/name: blue-service
        app.kubernetes.io/version: "1.0"
    spec:
      containers:
        - env:
            - name: KUBERNETES_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          image: quay.io/quarkus/blue-service:1.0
          imagePullPolicy: Always
          name: blue-service
          ports:
            - containerPort: 8080
              name: http
              protocol: TCP
---
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    app.quarkus.io/commit-id: 27be03414510f776ca70d70d859b33e134570443
    app.quarkus.io/build-timestamp: 2022-03-31 - 10:38:54 +0000
  labels:
    color: red
    type: color-service
    app.kubernetes.io/version: "1.0"
    app.kubernetes.io/name: red-service
  name: red-service <i class="conum" data-value="2"></i><b>(2)</b>
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/version: "1.0"
      app.kubernetes.io/name: red-service
  template:
    metadata:
      annotations:
        app.quarkus.io/commit-id: 27be03414510f776ca70d70d859b33e134570443
        app.quarkus.io/build-timestamp: 2022-03-31 - 10:38:54 +0000
      labels:
        color: red
        type: color-service
        app.kubernetes.io/version: "1.0"
        app.kubernetes.io/name: red-service
    spec:
      containers:
        - env:
            - name: KUBERNETES_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          image: quay.io/quarkus/red-service:1.0
          imagePullPolicy: Always
          name: red-service
          ports:
            - containerPort: 8080
              name: http
              protocol: TCP
---
apiVersion: networking.k8s.io/v1
kind: Ingress <i class="conum" data-value="3"></i><b>(3)</b>
metadata:
  annotations:
    app.quarkus.io/commit-id: f747f359406bedfb1a39c57392a5b5a9eaefec56
    app.quarkus.io/build-timestamp: 2022-03-31 - 10:46:19 +0000
  labels:
    app.kubernetes.io/name: color-service
    app.kubernetes.io/version: "1.0"
    color: blue
    type: color-service
  name: color-service
spec:
  rules:
    - host: color-service.127.0.0.1.nip.io
      http:
        paths:
          - backend:
              service:
                name: color-service
                port:
                  name: http
            path: /
            pathType: Prefix</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are a few interesting parts in this listing:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The Kubernetes Service resource, <code>color-service</code>, that Stork will discover.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The Red and Blue service instances behind the <code>color-service</code> Kubernetes service.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>A Kubernetes Ingress resource making the <code>color-service</code> accessible from the outside of the cluster at the <code>color-service.127.0.0.1.nip.io</code> url. Note that the Ingress is not needed for Stork however, it helps to check that the architecture is in place.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Create a file named <code>kubernetes-setup.yml</code> with the content above at the root of the project and run the following commands to deploy all the resources in the Kubernetes cluster. Don&#8217;t forget to create a dedicated namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell script hljs" data-lang="shell script">kubectl create namespace development
kubectl apply -f kubernetes-setup.yml -n=development</code></pre>
</div>
</div>
<div class="paragraph">
<p>If everything went well the Color service is accessible on <a href="http://color-service.127.0.0.1.nip.io" class="bare">http://color-service.127.0.0.1.nip.io</a>. You should have <code>Hello from Red!</code> and <code>Hello from Blue!</code> response randomly.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Stork is not limited to Kubernetes and integrates with other service discovery mechanisms.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-rest-client-interface-and-the-front-end-api"><a class="anchor" href="#the-rest-client-interface-and-the-front-end-api"></a>The REST Client interface and the front end API</h2>
<div class="sectionbody">
<div class="paragraph">
<p>So far, we didn&#8217;t use Stork; we just deployed the services we will be discovering, selecting, and calling.</p>
</div>
<div class="paragraph">
<p>We will call the services using the Reactive REST Client.
Create the <code>src/main/java/org/acme/MyService.java</code> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import org.eclipse.microprofile.rest.client.inject.RegisterRestClient;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

/**
 * The REST Client interface.
 *
 * Notice the `baseUri`. It uses `stork://` as URL scheme indicating that the called service uses Stork to locate and
 * select the service instance. The `my-service` part is the service name. This is used to configure Stork discovery
 * and selection in the `application.properties` file.
 */
@RegisterRestClient(baseUri = "stork://my-service")
public interface MyService {

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    String get();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s a straightforward REST client interface containing a single method. However, note the <code>baseUri</code> attribute:
* the <code>stork://</code> suffix instructs the REST client to delegate the discovery and selection of the service instances to Stork,
* the <code>my-service</code> part of the URI is the service name we will be using in the application configuration.</p>
</div>
<div class="paragraph">
<p>It does not change how the REST client is used.
Create the <code>src/main/java/org/acme/FrontendApi.java</code> file with the following content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme;

import org.eclipse.microprofile.rest.client.inject.RestClient;

import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;
import jakarta.ws.rs.Produces;
import jakarta.ws.rs.core.MediaType;

/**
 * A frontend API using our REST Client (which uses Stork to locate and select the service instance on each call).
 */
@Path("/api")
public class FrontendApi {

    @RestClient MyService service;

    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String invoke() {
        return service.get();
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It injects and uses the REST client as usual.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="stork-configuration"><a class="anchor" href="#stork-configuration"></a>Stork configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Now we need to configure Stork for using Kubernetes to discover the red and blue instances of the service.</p>
</div>
<div class="paragraph">
<p>In the <code>src/main/resources/application.properties</code>, add:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.stork.my-service.service-discovery.type=kubernetes
quarkus.stork.my-service.service-discovery.k8s-namespace=development
quarkus.stork.my-service.service-discovery.application=color-service
quarkus.stork.my-service.load-balancer.type=random</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>stork.my-service.service-discovery</code> indicates which type of service discovery we will be using to locate the <code>my-service</code> service.
In our case, it&#8217;s <code>kubernetes</code>.
If your access to the Kubernetes cluster is configured via Kube config file, you don&#8217;t need to configure the access to it. Otherwise, set the proper Kubernetes url using the <code>quarkus.stork.my-service.service-discovery.k8s-host</code> property.
<code>quarkus.stork.my-service.service-discovery.application</code> contains the name of the Kubernetes service Stork is going to ask for. In our case, this is the <code>color-service</code> corresponding to the kubernetes service backed by the Red and Blue instances.
Finally, <code>quarkus.stork.my-service.load-balancer.type</code> configures the service selection. In our case, we use a <code>random</code> Load Balancer.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deploy-the-rest-client-interface-and-the-front-end-api-in-the-kubernetes-cluster"><a class="anchor" href="#deploy-the-rest-client-interface-and-the-front-end-api-in-the-kubernetes-cluster"></a>Deploy the REST Client interface and the front end API in the Kubernetes cluster</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The system is almost complete. We only need to deploy the REST Client interface and the client service to the cluster.
In the <code>src/main/resources/application.properties</code>, add:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.container-image.registry=&lt;public registry&gt;
quarkus.kubernetes-client.trust-certs=true
quarkus.kubernetes.ingress.expose=true
quarkus.kubernetes.ingress.host=my-service.127.0.0.1.nip.io</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>quarkus.container-image.registry</code> contains the container registry to use.
The <code>quarkus.kubernetes.ingress.expose</code> indicates that the service will be accessible from the outside of the cluster.
The <code>quarkus.kubernetes.ingress.host</code> contains the url to access the service. We are using <a href="https://nip.io/">nip.io</a> wildcard for IP address mappings.</p>
</div>
<div class="paragraph">
<p>For a more customized configuration you can check the <a href="https://quarkus.io/guides/deploying-to-kubernetes">Deploying to Kubernetes guide</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="build-and-push-the-container-image"><a class="anchor" href="#build-and-push-the-container-image"></a>Build and push the container image</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Thanks to the extensions we are using, we can perform the build of a container image using Jib and also enabling the generation of Kubernetes manifests while building the application. For example, the following command will generate a Kubernetes manifest in the <code>target/kubernetes/</code> directory and also build and push a container image for the project:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell script hljs" data-lang="shell script">./mvnw package -Dquarkus.container-image.build=true -Dquarkus.container-image.push=true</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deploy-client-service-to-the-kubernetes-cluster"><a class="anchor" href="#deploy-client-service-to-the-kubernetes-cluster"></a>Deploy client service to the Kubernetes cluster</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The generated manifest can be applied to the cluster from the project root using kubectl:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell script hljs" data-lang="shell script">kubectl apply -f target/kubernetes/kubernetes.yml -n=development</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Please note that if you use Elliptic Curve keys with Stork and are getting exceptions like <code>java.lang.ClassNotFoundException: org.bouncycastle.jce.provider.BouncyCastleProvider</code>, then adding a BouncyCastle PKIX dependency (<code>org.bouncycastle:bcpkix-jdk18on</code>) is required.</p>
</div>
<div class="paragraph">
<p>Note that internally an <code>org.bouncycastle.jce.provider.BouncyCastleProvider</code> provider will be registered if it has not already been registered.</p>
</div>
<div class="paragraph">
<p>You can have this provider registered as described in the <a href="security-customization#bouncy-castle">BouncyCastle</a> or <a href="security-customization#bouncy-castle-fips">BouncyCastle FIPS</a> sections.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We&#8217;re done!
So, let&#8217;s see if it works.</p>
</div>
<div class="paragraph">
<p>Open a browser and navigate to <a href="http://my-service.127.0.0.1.nip.io/api" class="bare">http://my-service.127.0.0.1.nip.io/api</a>.</p>
</div>
<div class="paragraph">
<p>Or if you prefer, in another terminal, run:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell script hljs" data-lang="shell script">&gt; curl http://my-service.127.0.0.1.nip.io/api
...
&gt; curl http://my-service.127.0.0.1.nip.io/api
...
&gt; curl http://my-service.127.0.0.1.nip.io/api
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The responses should alternate randomly between <code>Hello from Red!</code> and <code>Hello from Blue!</code>.</p>
</div>
<div class="paragraph">
<p>You can compile this application into a native executable:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in stork-kubernetes.adoc - include::{includes}/devtools/build-native.adoc[]</p>
</div>
<div class="paragraph">
<p>Then, you need to build a container image based on the native executable. For this use the corresponding Dockerfile:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell script hljs" data-lang="shell script">&gt; docker build -f src/main/docker/Dockerfile.native -t quarkus/stork-kubernetes-quickstart .</code></pre>
</div>
</div>
<div class="paragraph">
<p>After publishing the new image to the container registry. You can redeploy the Kubernetes manifest to the cluster.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="going-further"><a class="anchor" href="#going-further"></a>Going further</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This guide has shown how to use SmallRye Stork to discover and select your services.
You can find more about Stork in:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the <a href="stork-reference">Stork reference guide</a>,</p>
</li>
<li>
<p>the <a href="stork">Stork with Consul reference guide</a>,</p>
</li>
<li>
<p>the <a href="https://smallrye.io/smallrye-stork">SmallRye Stork website</a>.</p>
</li>
</ul>
</div>
</div>
</div>