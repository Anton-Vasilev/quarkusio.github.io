<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Proactive authentication is enabled in Quarkus by default. This means that if an incoming request has a credential then that request will always be authenticated, even if the target page does not require authentication.</p>
</div>
<div id="proactive-authentication" class="paragraph">
<p>Requests with an invalid credential will always be rejected, even when the page is public.</p>
</div>
<div class="paragraph">
<p>If you only want to authenticate when the target page requires authentication, you can change the default behavior.</p>
</div>
<div class="paragraph">
<p>To disable proactive authentication in Quarkus, set the following attribute in the <code>application.properties</code> configuration file:</p>
</div>
<div class="listingblock white-space-pre">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">`quarkus.http.auth.proactive=false`</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you disable proactive authentication, the authentication process runs only when an identity is requested.
An identity can be requested because of security rules that require the user to authenticate or because programmatic access to the current identity is required.</p>
</div>
<div class="paragraph">
<p>If proactive authentication is in use, accessing <code>SecurityIdentity</code> is a blocking operation.
This is because authentication might have yet to happen and accessing <code>SecurityIdentity</code> might require calls to external systems, such as databases, that might block the operation.
For blocking applications, this is not an issue.
However, if you have disabled authentication in a reactive application, this will fail because you cannot do blocking operations on the I/O thread.
To work around this, you need to <code>@Inject</code> an instance of <code>io.quarkus.security.identity.CurrentIdentityAssociation</code> and call the <code>Uni&lt;SecurityIdentity&gt; getDeferredIdentity();</code> method.
Then, you can subscribe to the resulting <code>Uni</code> and will be notified when authentication is complete and the identity is available.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can still access <code>SecurityIdentity</code> synchronously with <code>public SecurityIdentity getIdentity()</code> in <a href="resteasy-reactive">RESTEasy Reactive</a> from endpoints that are annotated with <code>@RolesAllowed</code>, <code>@Authenticated</code>, or with respective configuration authorization checks because authentication has already happened.
The same is also valid for <a href="reactive-routes">Reactive routes</a> if a route response is synchronous.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="security-authorization#standard-security-annotations">Standard security annotations</a> on CDI beans are not supported on an I/O thread if a non-void secured method returns a value synchronously and proactive authentication is disabled because they need to access <code>SecurityIdentity</code>.</p>
</div>
<div class="paragraph">
<p>In the following example, <code>HelloResource</code> and <code>HelloService</code> are defined.
Any GET request to <code>/hello</code> will run on the I/O thread and throw a <code>BlockingOperationNotAllowedException</code> exception.</p>
</div>
<div class="paragraph">
<p>There is more than one way to fix the example:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Switch to a worker thread by annotating the <code>hello</code> endpoint with <code>@Blocking</code>.</p>
</li>
<li>
<p>Change the <code>sayHello</code> method return type by using a reactive or asynchronous data type.</p>
</li>
<li>
<p>Move <code>@RolesAllowed</code> annotation to the endpoint.
This could be one of the safest ways because accessing <code>SecurityIdentity</code> from endpoint methods is never the blocking operation.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.annotation.security.PermitAll;
import jakarta.inject.Inject;
import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import io.smallrye.mutiny.Uni;

@Path("/hello")
@PermitAll
public class HelloResource {

    @Inject
    HelloService helloService;

    @GET
    public Uni&lt;String&gt; hello() {
        return Uni.createFrom().item(helloService.sayHello());
    }

}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import jakarta.annotation.security.RolesAllowed;
import jakarta.enterprise.context.ApplicationScoped;

@ApplicationScoped
public class HelloService {

    @RolesAllowed("admin")
    public String sayHello() {
        return "Hello";
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="customize-authentication-exception-responses"><a class="anchor" href="#customize-authentication-exception-responses"></a>Customize authentication exception responses</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can use Jakarta REST <code>ExceptionMapper</code> to capture Quarkus Security authentication exceptions such as <code>io.quarkus.security.AuthenticationFailedException</code>, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.annotation.Priority;
import jakarta.ws.rs.Priorities;
import jakarta.ws.rs.core.Response;
import jakarta.ws.rs.ext.ExceptionMapper;
import jakarta.ws.rs.ext.Provider;

import io.quarkus.security.AuthenticationFailedException;

@Provider
@Priority(Priorities.AUTHENTICATION)
public class AuthenticationFailedExceptionMapper implements ExceptionMapper&lt;AuthenticationFailedException&gt; {

    @Context
    UriInfo uriInfo;

    @Override
    public Response toResponse(AuthenticationFailedException exception) {
        return Response.status(401).header("WWW-Authenticate", "Basic realm=\"Quarkus\"").build();
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
Some HTTP authentication mechanisms need to handle authentication exceptions themselves to create a correct authentication challenge.
For example, <code>io.quarkus.oidc.runtime.CodeAuthenticationMechanism</code>, which manages OpenID Connect (OIDC) authorization code flow authentication, needs to build a correct redirect URL, cookies, and so on.
For that reason, avoid using custom exception mappers to customize authentication exceptions thrown by such mechanisms.
Instead, a safer approach is to ensure that proactive authentication is enabled and to use Vert.x HTTP route failure handlers.
This is because events come to the handler with the correct response status and headers.
You then only need to customize the response, as shown in the following example:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package io.quarkus.it.keycloak;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.event.Observes;

import io.quarkus.security.AuthenticationFailedException;
import io.vertx.core.Handler;
import io.vertx.ext.web.Router;
import io.vertx.ext.web.RoutingContext;

@ApplicationScoped
public class AuthenticationFailedExceptionHandler {

    public void init(@Observes Router router) {
        router.route().failureHandler(new Handler&lt;RoutingContext&gt;() {
            @Override
            public void handle(RoutingContext event) {
                if (event.failure() instanceof AuthenticationFailedException) {
                    event.response().end("CUSTOMIZED_RESPONSE");
                } else {
                    event.next();
                }
            }
        });
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references"><a class="anchor" href="#references"></a>References</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="security-overview">Quarkus Security overview</a></p>
</li>
<li>
<p><a href="security-architecture">Quarkus Security architecture</a></p>
</li>
<li>
<p><a href="security-authentication-mechanisms">Authentication mechanisms in Quarkus</a></p>
</li>
<li>
<p><a href="security-identity-providers">Identity providers</a></p>
</li>
</ul>
</div>
</div>
</div>