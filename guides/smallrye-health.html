<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This guide demonstrates how your Quarkus application can use <a href="https://github.com/smallrye/smallrye-health/">SmallRye Health</a>
an implementation of the <a href="https://github.com/eclipse/microprofile-health/">MicroProfile Health</a> specification.</p>
</div>
<div class="paragraph">
<p>SmallRye Health allows applications to provide information about their state
to external viewers which is typically useful in cloud environments where automated
processes must be able to determine whether the application should be discarded
or restarted.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="prerequisites"><a class="anchor" href="#prerequisites"></a>Prerequisites</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unresolved directive in smallrye-health.adoc - include::{includes}/prerequisites.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="architecture"><a class="anchor" href="#architecture"></a>Architecture</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this guide, we build a simple REST application that exposes MicroProfile Health
functionalities at the <code>/q/health/live</code> and <code>/q/health/ready</code> endpoints according to the
specification.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="solution"><a class="anchor" href="#solution"></a>Solution</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We recommend that you follow the instructions in the next sections and create the
application step by step. However, you can go right to the completed example.</p>
</div>
<div class="paragraph">
<p>Clone the Git repository: <code>git clone <a href="https://github.com/quarkusio/quarkus-quickstarts.git" class="bare">https://github.com/quarkusio/quarkus-quickstarts.git</a></code>, or download an
<a href="https://github.com/quarkusio/quarkus-quickstarts/archive/main.zip">archive</a>.</p>
</div>
<div class="paragraph">
<p>The solution is located in the <code>microprofile-health-quickstart</code>
<a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/microprofile-health-quickstart">directory</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-the-maven-project"><a class="anchor" href="#creating-the-maven-project"></a>Creating the Maven Project</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First, we need a new project. Create a new project with the following command:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in smallrye-health.adoc - include::{includes}/devtools/create-app.adoc[]</p>
</div>
<div class="paragraph">
<p>This command generates a project, importing the <code>smallrye-health</code> extension.</p>
</div>
<div class="paragraph">
<p>If you already have your Quarkus project configured, you can add the <code>smallrye-health</code> extension
to your project by running the following command in your project base directory:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in smallrye-health.adoc - include::{includes}/devtools/extension-add.adoc[]</p>
</div>
<div class="paragraph">
<p>This will add the following to your build file:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-smallrye-health")</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="running-the-health-check"><a class="anchor" href="#running-the-health-check"></a>Running the health check</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Importing the <code>smallrye-health</code> extension directly exposes three REST endpoints:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/q/health/live</code> - The application is up and running.</p>
</li>
<li>
<p><code>/q/health/ready</code> - The application is ready to serve requests.</p>
</li>
<li>
<p><code>/q/health/started</code> - The application is started.</p>
</li>
<li>
<p><code>/q/health</code> - Accumulating all health check procedures in the application.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To check that the <code>smallrye-health</code> extension is working as expected:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>start your Quarkus application with:</p>
<div class="paragraph">
<p>Unresolved directive in smallrye-health.adoc - include::{includes}/devtools/dev.adoc[]</p>
</div>
</li>
<li>
<p>access the <code><a href="http://localhost:8080/q/health/live" class="bare">http://localhost:8080/q/health/live</a></code> endpoint using your browser or
<code>curl <a href="http://localhost:8080/q/health/live" class="bare">http://localhost:8080/q/health/live</a></code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All <code>health</code> REST endpoints return a simple JSON object with two fields:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>status</code>&#8201;&#8212;&#8201;the overall result of all the health check procedures</p>
</li>
<li>
<p><code>checks</code>&#8201;&#8212;&#8201;an array of individual checks</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The general <code>status</code> of the health check is computed as a logical AND of all the
declared health check procedures. The <code>checks</code> array is empty as we have not specified
any health check procedure yet so let&#8217;s define some.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Management interface</div>
<div class="paragraph">
<p>By default, the health checks are exposed on the main HTTP server.
You can expose them on a separate network interface and port by enabling the management interface with the
<code>quarkus.management.enabled=true</code> property.
Refer to the <a href="./management-interface-reference">management interface reference</a> for more information.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="creating-your-first-health-check"><a class="anchor" href="#creating-your-first-health-check"></a>Creating your first health check</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, we create our first simple health check procedure.</p>
</div>
<div class="paragraph">
<p>Create the <code>org.acme.microprofile.health.SimpleHealthCheck</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.microprofile.health;

import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import org.eclipse.microprofile.health.Liveness;

import jakarta.enterprise.context.ApplicationScoped;

@Liveness
@ApplicationScoped <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
public class SimpleHealthCheck implements HealthCheck {

    @Override
    public HealthCheckResponse call() {
        return HealthCheckResponse.up("Simple health check");
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>It&#8217;s recommended to annotate the health check class with <code>@ApplicationScoped</code> or the <code>@Singleton</code> scope so that a single bean instance is used for all health check requests.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>If a bean class annotated with one of the health check annotations declares no scope then the <code>@Singleton</code> scope is used automatically.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As you can see, the health check procedures are defined as CDI beans that implement the <code>HealthCheck</code> interface and are annotated with one of the health check qualifiers, such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Liveness</code> - the liveness check accessible at <code>/q/health/live</code></p>
</li>
<li>
<p><code>@Readiness</code> - the readiness check accessible at <code>/q/health/ready</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>HealthCheck</code> is a functional interface whose single method <code>call</code> returns a
<code>HealthCheckResponse</code> object which can be easily constructed by the fluent builder
API shown in the example.</p>
</div>
<div class="paragraph">
<p>As we have started our Quarkus application in dev mode simply repeat the request
to <code><a href="http://localhost:8080/q/health/live" class="bare">http://localhost:8080/q/health/live</a></code> by refreshing your browser window or by
using <code>curl <a href="http://localhost:8080/q/health/live" class="bare">http://localhost:8080/q/health/live</a></code>. Because we defined our health check
to be a liveness procedure (with <code>@Liveness</code> qualifier) the new health check procedure
is now present in the <code>checks</code> array.</p>
</div>
<div class="paragraph">
<p>Congratulations! You&#8217;ve created your first Quarkus health check procedure. Let&#8217;s
continue by exploring what else can be done with SmallRye Health.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="adding-a-readiness-health-check-procedure"><a class="anchor" href="#adding-a-readiness-health-check-procedure"></a>Adding a readiness health check procedure</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous section, we created a simple liveness health check procedure which states
whether our application is running or not. In this section, we will create a readiness
health check which will be able to state whether our application is able to process
requests.</p>
</div>
<div class="paragraph">
<p>We will create another health check procedure that simulates a connection to
an external service provider such as a database. For starters, we will always return
the response indicating the application is ready.</p>
</div>
<div class="paragraph">
<p>Create <code>org.acme.microprofile.health.DatabaseConnectionHealthCheck</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.microprofile.health;

import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import org.eclipse.microprofile.health.Readiness;

import jakarta.enterprise.context.ApplicationScoped;

@Readiness
@ApplicationScoped
public class DatabaseConnectionHealthCheck implements HealthCheck {

    @Override
    public HealthCheckResponse call() {
        return HealthCheckResponse.up("Database connection health check");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you now rerun the health check at <code><a href="http://localhost:8080/q/health/live" class="bare">http://localhost:8080/q/health/live</a></code> the <code>checks</code>
array will contain only the previously defined <code>SimpleHealthCheck</code> as it is the only
check defined with the <code>@Liveness</code> qualifier. However, if you access
<code><a href="http://localhost:8080/q/health/ready" class="bare">http://localhost:8080/q/health/ready</a></code> (in the browser or with
<code>curl <a href="http://localhost:8080/q/health/ready" class="bare">http://localhost:8080/q/health/ready</a></code>) you will see only the
<code>Database connection health check</code> as it is the only health check defined with the
<code>@Readiness</code> qualifier as the readiness health check procedure.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you access <code><a href="http://localhost:8080/q/health" class="bare">http://localhost:8080/q/health</a></code> you will get back both checks.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>More information about which health check procedures should be used in which situation
is detailed in the MicroProfile Health specification. Generally, the liveness
procedures determine whether the application should be restarted while readiness
procedures determine whether it makes sense to contact the application with requests.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="adding-a-startup-health-check-procedure"><a class="anchor" href="#adding-a-startup-health-check-procedure"></a>Adding a startup health check procedure</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The third and final type of health check procedures is startup. Startup procedures are defined as an option for slow starting containers (should not be needed in Quarkus) to delay the invocations of liveness probe which will take over from startup once the startup responds UP for the first time. Startup health checks are defined with the <code>@Startup</code> qualifier.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please make sure that you import the microprofile <code>org.eclipse.microprofile.health.Startup</code> annotation since there is an unfortunate clash with <code>io.quarkus.runtime.Startup</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Create <code>org.acme.microprofile.health.StartupHealthCheck</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.microprofile.health;

import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import org.eclipse.microprofile.health.Startup;

import jakarta.enterprise.context.ApplicationScoped;

@Startup
@ApplicationScoped
public class StartupHealthCheck implements HealthCheck {

    @Override
    public HealthCheckResponse call() {
        return HealthCheckResponse.up("Startup health check");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The startup health check will be available either at <code><a href="http://localhost:8080/q/health/started" class="bare">http://localhost:8080/q/health/started</a></code> or together with other health check procedure at <code><a href="http://localhost:8080/q/health" class="bare">http://localhost:8080/q/health</a></code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="negative-health-check-procedures"><a class="anchor" href="#negative-health-check-procedures"></a>Negative health check procedures</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, we extend our <code>Database connection health check</code> with the option of
stating that our application is not ready to process requests as the underlying
database connection cannot be established. For simplicity reasons, we only determine
whether the database is accessible or not by a configuration property.</p>
</div>
<div class="paragraph">
<p>Update the <code>org.acme.microprofile.health.DatabaseConnectionHealthCheck</code> class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.microprofile.health;

import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import org.eclipse.microprofile.health.HealthCheckResponseBuilder;
import org.eclipse.microprofile.health.Readiness;

import jakarta.enterprise.context.ApplicationScoped;

@Readiness
@ApplicationScoped
public class DatabaseConnectionHealthCheck implements HealthCheck {

    @ConfigProperty(name = "database.up", defaultValue = "false")
    private boolean databaseUp;

    @Override
    public HealthCheckResponse call() {

        HealthCheckResponseBuilder responseBuilder = HealthCheckResponse.named("Database connection health check");

        try {
            simulateDatabaseConnectionVerification();
            responseBuilder.up();
        } catch (IllegalStateException e) {
            // cannot access the database
            responseBuilder.down();
        }

        return responseBuilder.build();
    }

    private void simulateDatabaseConnectionVerification() {
        if (!databaseUp) {
            throw new IllegalStateException("Cannot contact database");
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Until now, we used a simplified method of building a <code>HealthCheckResponse</code>
through the <code>HealthCheckResponse#up(String)</code> (there is also
<code>HealthCheckResponse#down(String)</code>) which will directly build the response object.
From now on, we utilize the full builder capabilities provided by the
<code>HealthCheckResponseBuilder</code> class.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you now rerun the readiness health check (at <code><a href="http://localhost:8080/q/health/ready" class="bare">http://localhost:8080/q/health/ready</a></code>)
the overall <code>status</code> should be DOWN. You can also check the liveness check at
<code><a href="http://localhost:8080/q/health/live" class="bare">http://localhost:8080/q/health/live</a></code> which will return the overall <code>status</code> UP because
it isn&#8217;t influenced by the readiness checks.</p>
</div>
<div class="paragraph">
<p>As we shouldn&#8217;t leave this application with a readiness check in a DOWN state and
because we are running Quarkus in dev mode you can add <code>database.up=true</code> in
<code>src/main/resources/application.properties</code> and rerun the readiness health check again&#8201;&#8212;&#8201;it should be up again.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="adding-user-specific-data-to-the-health-check-response"><a class="anchor" href="#adding-user-specific-data-to-the-health-check-response"></a>Adding user-specific data to the health check response</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In previous sections, we saw how to create simple health checks with only the minimal
attributes, namely, the health check name and its status (UP or DOWN). However, the
MicroProfile Health specification also provides a way for the applications to supply
arbitrary data in the form of key-value pairs sent to the consuming end. This can be
done by using the <code>withData(key, value)</code> method of the health check response
builder API.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create a new health check procedure <code>org.acme.microprofile.health.DataHealthCheck</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.microprofile.health;

import org.eclipse.microprofile.health.Liveness;
import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;

import jakarta.enterprise.context.ApplicationScoped;

@Liveness
@ApplicationScoped
public class DataHealthCheck implements HealthCheck {

    @Override
    public HealthCheckResponse call() {
        return HealthCheckResponse.named("Health check with data")
                .up()
                .withData("foo", "fooValue")
                .withData("bar", "barValue")
                .build();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you rerun the liveness health check procedure by accessing the <code>/q/health/live</code>
endpoint you can see that the new health check <code>Health check with data</code> is present
in the <code>checks</code> array. This check contains a new attribute called <code>data</code> which is a
JSON object consisting of the properties we have defined in our health check procedure.</p>
</div>
<div class="paragraph">
<p>This functionality is specifically useful in failure scenarios where you can pass the
error along with the health check response.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        try {
            simulateDatabaseConnectionVerification();
            responseBuilder.up();
        } catch (IllegalStateException e) {
            // cannot access the database
            responseBuilder.down()
                    .withData("error", e.getMessage()); // pass the exception message
        }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="context-propagation-into-the-health-check-invocations"><a class="anchor" href="#context-propagation-into-the-health-check-invocations"></a>Context propagation into the health check invocations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For performance reasons, the context (e.g., CDI or security context) is not propagated into each health check invocation. However, if you need to enable this functionality you can set the config property <code>quarkus.smallrye-health.context-propagation=true</code> to allow the context propagation into every health check call.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactive-health-checks"><a class="anchor" href="#reactive-health-checks"></a>Reactive health checks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>MicroProfile Health currently doesn&#8217;t support returning reactive types, but SmallRye Health does.</p>
</div>
<div class="paragraph">
<p>If you want to provide a reactive health check, you can implement the <code>io.smallrye.health.api.AsyncHealthCheck</code> interface instead of the <code>org.eclipse.microprofile.health.HealthCheck</code> one.
The <code>io.smallrye.health.api.AsyncHealthCheck</code> interface allows you to return a <code>Uni&lt;HealthCheckResponse&gt;</code>.</p>
</div>
<div class="paragraph">
<p>The following example shows a reactive liveness check:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.smallrye.health.api.AsyncHealthCheck;

import org.eclipse.microprofile.health.Liveness;
import org.eclipse.microprofile.health.HealthCheckResponse;

import jakarta.enterprise.context.ApplicationScoped;

@Liveness
@ApplicationScoped
public class LivenessAsync implements AsyncHealthCheck {

    @Override
    public Uni&lt;HealthCheckResponse&gt; call() {
        return Uni.createFrom().item(HealthCheckResponse.up("liveness-reactive"))
                .onItem().delayIt().by(Duration.ofMillis(10));
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="extension-health-checks"><a class="anchor" href="#extension-health-checks"></a>Extension health checks</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some extension may provide default health checks, including the extension will automatically register its health checks.</p>
</div>
<div class="paragraph">
<p>For example, <code>quarkus-agroal</code> that is used to manage Quarkus datasource(s) automatically register a readiness health check
that will validate each datasource: <a href="datasource#datasource-health-check">Datasource Health Check</a>.</p>
</div>
<div class="paragraph">
<p>You can disable extension health checks via the property <code>quarkus.health.extensions.enabled</code> so none will be automatically registered.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ui"><a class="anchor" href="#ui"></a>Health UI</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Experimental - not included in the MicroProfile specification
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>health-ui</code> allows you to see your Health Checks in a Web GUI.</p>
</div>
<div class="paragraph">
<p>The Quarkus <code>smallrye-health</code> extension ships with <code>health-ui</code> and enables it by default in dev and test modes, but it can also be explicitly configured for production mode as well.</p>
</div>
<div class="paragraph">
<p><code>health-ui</code> can be accessed from <a href="http://localhost:8080/q/health-ui/" class="bare">http://localhost:8080/q/health-ui/</a> .</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="health-ui-screenshot01.png" alt="Health UI"></span></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="management-interface"><a class="anchor" href="#management-interface"></a>Management interface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, the health checks are exposed on the main HTTP server.
You can expose them on a separate network interface and port by setting <code>quarkus.management.enabled=true</code> in your application configuration.
Note that this property is a build-time property.
The value cannot be overridden at runtime.</p>
</div>
<div class="paragraph">
<p>If you enable the management interface without customizing the management network interface and port, the health checks are exposed under: <code><a href="http://0.0.0.0:9000/q/health" class="bare">http://0.0.0.0:9000/q/health</a></code>.
You can configure the <em>path</em> (the <code>health</code> segment in the previous URL) using the <code>quarkus.smallrye-health.root-path</code> property.</p>
</div>
<div class="paragraph">
<p>Refer to the <a href="./management-interface-reference">management interface reference</a> for more information.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conclusion"><a class="anchor" href="#conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>SmallRye Health provides a way for your application to distribute information
about its healthiness state to state whether it is able to function properly.
Liveness checks are utilized to tell whether the application should be restarted and
readiness checks are used to tell whether the application is able to process requests.</p>
</div>
<div class="paragraph">
<p>All that is needed to enable the SmallRye Health features in Quarkus is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>adding the <code>smallrye-health</code> Quarkus extension to your project using the
<code>quarkus-maven-plugin</code>:</p>
<div class="paragraph">
<p>Unresolved directive in smallrye-health.adoc - include::{includes}/devtools/extension-add.adoc[]
:!devtools-wrapped:</p>
</div>
</li>
<li>
<p>or simply adding the following Maven dependency:</p>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-smallrye-health&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-smallrye-health")</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration-reference"><a class="anchor" href="#configuration-reference"></a>Configuration Reference</h2>
<div class="sectionbody">

</div>
</div>