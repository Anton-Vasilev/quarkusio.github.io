<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus Funqy <a href="https://knative.dev/docs/eventing">Knative Events</a> builds off of the <a href="funqy-http">Funqy HTTP</a> extension to allow you to
route and process Knative Events within a Funqy function.</p>
</div>
<div class="paragraph">
<p>The guide walks through quickstart code to show you how you can deploy and invoke on Funqy functions
with Knative Events.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="prerequisites"><a class="anchor" href="#prerequisites"></a>Prerequisites</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Unresolved directive in funqy-knative-events.adoc - include::{includes}/prerequisites.adoc[]
* Read about <a href="funqy">Funqy Basics</a>.  This is a short read!
* Have gone through the <a href="https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html">Knative Tutorial</a>, specifically <a href="https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/eventing/eventing-trigger-broker.html">Brokers and Triggers</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="setting-up-knative"><a class="anchor" href="#setting-up-knative"></a>Setting up Knative</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Setting up Knative locally in a Minikube environment is beyond the scope of this guide.  It is advised
to follow  <a href="https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/index.html">this</a> Knative Tutorial
put together by Red Hat.  It walks through how to set up Knative on Minikube or OpenShift in a local environment.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Specifically you should run the <a href="https://redhat-developer-demos.github.io/knative-tutorial/knative-tutorial/eventing/eventing-trigger-broker.html">Brokers and Triggers</a>
tutorial as this guide requires that you can invoke on a Broker to trigger the quickstart code.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="read-about-cloud-events"><a class="anchor" href="#read-about-cloud-events"></a>Read about Cloud Events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Cloud Event <a href="https://cloudevents.io/">specification</a> is a good read to give you an even greater understanding of Knative Events.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-quickstart"><a class="anchor" href="#the-quickstart"></a>The Quickstart</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clone the Git repository: <code>git clone <a href="https://github.com/quarkusio/quarkus-quickstarts.git" class="bare">https://github.com/quarkusio/quarkus-quickstarts.git</a></code>, or download an <a href="https://github.com/quarkusio/quarkus-quickstarts/archive/main.zip">archive</a>.</p>
</div>
<div class="paragraph">
<p>The solution is located in the <code>funqy-knative-events-quickstart</code> <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/funqy-quickstarts/funqy-knative-events-quickstart">directory</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-quickstart-flow"><a class="anchor" href="#the-quickstart-flow"></a>The Quickstart Flow</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The quickstart works by manually sending an HTTP request containing a Cloud Event to the Knative Broker using <code>curl</code>.
The Knative Broker receives the request and triggers the startup of the Funqy container built by the quickstart.
The event triggers the invocation of a chain of Funqy functions.  The output of one function triggers the
invocation of another Funqy function.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="funqy-and-cloud-events"><a class="anchor" href="#funqy-and-cloud-events"></a>Funqy and Cloud Events</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When living within a Knative Events environment, Funqy functions are triggered by a specific
Cloud Event type.  You can have multiple Funqy functions within a single application/deployment,
but they must be triggered by a specific Cloud Event Type.  The exception to this rule is if there is
only one Funqy function in the application.  In that case, the event is pushed to that function irregardless
of the Cloud Event type.</p>
</div>
<div class="paragraph">
<p>Currently, Funqy can only consume JSON-based data.  It supports both Binary and Structured mode of execution,
but the data component of the Cloud Event message must be JSON.  This JSON must also be marshallable to and from the
Java parameters and return types of your functions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-code"><a class="anchor" href="#the-code"></a>The Code</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s start looking at our quickstart code so that you can understand how Knative Events map to Funqy.
Open up <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/funqy-quickstarts/funqy-knative-events-quickstart/src/main/java/org/acme/funqy/SimpleFunctionChain.java">SimpleFunctionChain.java</a></p>
</div>
<div class="paragraph">
<p>The first function we&#8217;ll look at is <code>defaultChain</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.funqy.Funq;

public class SimpleFunctionChain {
    @Funq
    public String defaultChain(String input) {
        log.info("*** defaultChain ***");
        return input + "::" + "defaultChain";
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>As is, a Funqy function has a default Cloud Event mapping.  By default, the Cloud Event type must match
the function name for the function to trigger.  If the function returns output,
the response is converted into a Cloud Event and returned to the Broker to be routed to other triggers.
The default Cloud Event type for this response is the function name + <code>.output</code>.  The default Cloud Event source is the function name.</p>
</div>
<div class="paragraph">
<p>So, for the <code>defaultChain</code> function, the Cloud Event type that triggers the function is <code>defaultChain</code>.  It generates
a response that triggers a new Cloud Event whose type is <code>defaultChain.output</code> and the event source is <code>defaultChain</code>.</p>
</div>
<div class="paragraph">
<p>While the default mapping is simple, it might not always be feasible.  You can change this default mapping
through configuration.  Let&#8217;s look at the next function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.funqy.Funq;

public class SimpleFunctionChain {
    @Funq
    public String configChain(String input) {
        log.info("*** configChain ***");
        return input + "::" + "configChain";
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>configChain</code> function has its Cloud Event mapping changed by configuration within <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/funqy-quickstarts/funqy-knative-events-quickstart/src/main/resources/application.properties">application.properties</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.funqy.knative-events.mapping.configChain.trigger=defaultChain.output
quarkus.funqy.knative-events.mapping.configChain.response-type=annotated
quarkus.funqy.knative-events.mapping.configChain.response-source=configChain</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, the configuration maps the incoming Cloud Event type <code>defaultChain.output</code> to the <code>configChain</code> function.
The <code>configChain</code> function maps its response to the <code>annotated</code> Cloud Event type, and the Cloud Event source <code>configChain</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>quarkus.funqy.knative-events.mapping.{function name}.trigger</code> sets the Cloud Event type that triggers a specific function. It is possible to use the special value <code>*</code> as a catch-all value. The function will in this case be used for all event types.</p>
</li>
<li>
<p><code>quarkus.funqy.knative-events.mapping.{function name}.response-type</code> sets the Cloud Event type of the response</p>
</li>
<li>
<p><code>quarkus.funqy.knative-events.mapping.{function name}.resource-source</code> sets the Cloud Event source of the response</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Funqy Knative Events extension also has annotations to do this Cloud Event mapping to your functions.  Take a look at the
<code>annotatedChain</code> method</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.funqy.Funq;
import io.quarkus.funqy.knative.events.CloudEventMapping;

public class SimpleFunctionChain {
    @Funq
    @CloudEventMapping(trigger = "annotated", responseSource = "annotated", responseType = "lastChainLink")
    public String annotatedChain(String input) {
        log.info("*** annotatedChain ***");
        return input + "::" + "annotatedChain";
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use the <code>@CloudEventMapping</code> annotation on your function you can map the Cloud Event type trigger
and the Cloud Event response.  In this example the <code>annotatedChain</code> function will be triggered
by the <code>annotated</code> Cloud Event type and the response will be mapped to a <code>lastChainLink</code> type
and <code>annotated</code> Cloud Event source.</p>
</div>
<div class="paragraph">
<p>So, if you look at all the functions defined within <code>SimpleFunctionChain</code> you&#8217;ll notice that one function triggers the next.
The last function that is triggered is <code>lastChainLink</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">import io.quarkus.funqy.Context;
import io.quarkus.funqy.Funq;

public class SimpleFunctionChain {
    @Funq
    public void lastChainLink(String input, @Context CloudEvent event) {
        log.info("*** lastChainLink ***");
        log.info(input + "::" + "lastChainLink");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are two things to notice about this function.  One, it has no output.  Your functions are not
required to return output.  Second, there is an additional <code>event</code> parameter to the function.</p>
</div>
<div class="paragraph">
<p>If you want to know additional information about the incoming Cloud Event, you can inject the
<code>io.quarkus.funqy.knative.events.CloudEvent</code> interface using the Funqy <code>@Context</code> annotation.  The <code>CloudEvent</code> interface exposes information
about the triggering event.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface CloudEvent {
    String id();
    String specVersion();
    String source();
    String subject();
    OffsetDateTime time();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="maven"><a class="anchor" href="#maven"></a>Maven</h2>
<div class="sectionbody">
<div class="paragraph">
<p>If you look at the <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/funqy-quickstarts/funqy-knative-events-quickstart/pom.xml">POM</a>,
you&#8217;ll see that it is a typical Quarkus POM that pulls in one Funqy dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-funqy-knative-events&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dev-mode-and-testing"><a class="anchor" href="#dev-mode-and-testing"></a>Dev mode and Testing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Funqy Knative Events support dev mode and unit testing using RestAssured.  You can invoke on Funqy Knative Events functions
using the same invocation model as
<a href="funqy-http">Funqy HTTP</a> using normal HTTP requests, or Cloud Event Binary mode, or Structured Mode.  All
invocation modes are supported at the same time.</p>
</div>
<div class="paragraph">
<p>So, if you open up the unit test code in <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/funqy-quickstarts/funqy-knative-events-quickstart/src/test/java/org/acme/funqy/FunqyTest.java">FunqyTest.java</a>
you&#8217;ll see that its simply using RestAssured to make HTTP invocations to test the functions.</p>
</div>
<div class="paragraph">
<p>Funqy also works with Quarkus Dev mode!</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="build-the-project"><a class="anchor" href="#build-the-project"></a>Build the Project</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First build the Java artifacts:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in funqy-knative-events.adoc - include::{includes}/devtools/build.adoc[]</p>
</div>
<div class="paragraph">
<p>Next, a docker image is required by Knative, so you&#8217;ll need to build that next:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker build -f src/main/docker/Dockerfile.jvm -t yourAccountName/funqy-knative-events-quickstart .</code></pre>
</div>
</div>
<div class="paragraph">
<p>Make sure to replace <code>yourAccountName</code> with your docker or quay account name when you run <code>docker build</code>.  The
Dockerfile is a standard Quarkus dockerfile.  No special Knative magic.</p>
</div>
<div class="paragraph">
<p>Push your image to docker hub or quay</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">docker push yourAccountName/funqy-knative-events-quickstart</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, make sure to replace <code>yourAccountName</code> with your docker or quay account name when you run <code>docker push</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="deploy-to-kubernetesopenshift"><a class="anchor" href="#deploy-to-kubernetesopenshift"></a>Deploy to Kubernetes/OpenShift</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The first step is to set up the broker in our namespace.
Following is an example command from the Knative cli.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">kn broker create default \
  --namespace knativetutorial</code></pre>
</div>
</div>
<div class="paragraph">
<p>The broker we have created is called <code>default</code>, this broker will receive the cloud events.
The broker is also referenced in the function YAML files.</p>
</div>
<div class="paragraph">
<p>The second step is to define a Kubernetes/OpenShift service to point to the Docker image you created and pushed
during build. Take a look at <a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/funqy-service.yaml">funqy-service.yaml</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: funqy-knative-events-quickstart
spec:
  template:
    metadata:
      name: funqy-knative-events-quickstart-v1
      annotations:
        autoscaling.knative.dev/target: "1"
    spec:
      containers:
        - image: docker.io/yourAccountName/funqy-knative-events-quickstart</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is a standard Kubernetes service definition YAML file.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Make sure you change the image URL to point to the image you built and pushed earlier!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For our quickstart, one Kubernetes service will contain all functions. There&#8217;s no reason you couldn&#8217;t break up this
quickstart into multiple different projects and deploy a service for each function.  For simplicity, and to show that you
don&#8217;t have to have a deployment per function, the quickstart combines everything into one project, image, and service.</p>
</div>
<div class="paragraph">
<p>Deploy the service:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -n knativetutorial -f src/main/k8s/funqy-service.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next step is to deploy Knative Event triggers for each of the event types. As noted in the code section, each
Funqy function is mapped to a specific Cloud Event type.  You must create Knative Event triggers that map a Cloud Event
and route it to a specific Kubernetes service.  We have 4 different triggers.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/quarkusio/quarkus-quickstarts/tree/main/funqy-quickstarts/funqy-knative-events-quickstart/src/main/k8s/defaultChain-trigger.yaml">defaultChain-trigger.yaml</a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: eventing.knative.dev/v1alpha1
kind: Trigger
metadata:
  name: defaultchain
spec:
  broker: default
  filter:
    attributes:
      type: defaultChain
  subscriber:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: funqy-knative-events-quickstart</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>spec:filter:attributes:type</code> maps a Cloud Event type to the Kubernetes service defined in <code>spec:subscriber:ref</code>.
When a Cloud Event is pushed to the Broker, it will trigger the spin up of the service mapped to that event.</p>
</div>
<div class="paragraph">
<p>There&#8217;s a trigger YAML file for each of our 4 Funqy functions.  Deploy them all:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl apply -n knativetutorial -f src/main/k8s/defaultChain-trigger.yaml
kubectl apply -n knativetutorial -f src/main/k8s/configChain-trigger.yaml
kubectl apply -n knativetutorial -f src/main/k8s/annotatedChain-trigger.yaml
kubectl apply -n knativetutorial -f src/main/k8s/lastChainLink-trigger.yaml</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="run-the-demo"><a class="anchor" href="#run-the-demo"></a>Run the demo</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You&#8217;ll need two different terminal windows.  One to do a curl request to the Broker, the other to watch the pod log
files, so you can see the messages flowing through the Funqy function event chain.</p>
</div>
<div class="paragraph">
<p>Make sure you have the <code>stern</code> tool installed.  See the Knative Tutorial setup for information on that.  Run stern
to look for logs outputted by our Funqy deployment</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">stern funq user-container</code></pre>
</div>
</div>
<div class="paragraph">
<p>Open a separate terminal.  You&#8217;ll first need to learn the URL of the broker.  Execute this command to find it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl get broker default -o jsonpath='{.status.address.url}'</code></pre>
</div>
</div>
<div class="paragraph">
<p>This will provide you a URL similar to e.g.: <code><a href="http://broker-ingress.knative-eventing.svc.cluster.local/knativetutorial/default" class="bare">http://broker-ingress.knative-eventing.svc.cluster.local/knativetutorial/default</a></code>. Remember this URL.</p>
</div>
<div class="paragraph">
<p>Next thing we need to do is ssh into our Kubernetes cluster so that we can send a curl request to our broker.
The following command will create a simple OS pod so we can curl into our functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl -n knativetutorial apply -f src/main/k8s/curler.yaml</code></pre>
</div>
</div>
<div class="paragraph">
<p>You might need to wait a couple of seconds until the curler pod comes up. Run the following to get bash access to the curler pod:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">kubectl -n knativetutorial exec -it curler -- /bin/bash</code></pre>
</div>
</div>
<div class="paragraph">
<p>You will now be in a shell within the Kubernetes cluster.  Within the shell, execute this curl command , the broker address is an example and might differ based on your project or broker name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">curl -v "http://default-broker.knativetutorial.svc.cluster.local" \
-X POST \
-H "Ce-Id: 1234" \
-H "Ce-Specversion: 1.0" \
-H "Ce-Type: defaultChain" \
-H "Ce-Source: curl" \
-H "Content-Type: application/json" \
-d '"Start"'</code></pre>
</div>
</div>
<div class="paragraph">
<p>This posts a Knative Event to the broker, which will trigger the <code>defaultChain</code> function.  As discussed earlier, the output
of <code>defaultChain</code> triggers an event that is posted to <code>configChain</code> which triggers an event posted to <code>annotatedChain</code> then
finally to the <code>lastChainLink</code> function.  You can see this flow in your <code>stern</code> window.  Something like this should
be outputted.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">funqy-knative-events-quickstart-v1-deployment-59bb88bcf4-9jwdx user-container 2020-05-12 13:44:02,256 INFO  [org.acm.fun.SimpleFunctionChain] (executor-thread-1) *** defaultChain ***
funqy-knative-events-quickstart-v1-deployment-59bb88bcf4-9jwdx user-container 2020-05-12 13:44:02,365 INFO  [org.acm.fun.SimpleFunctionChain] (executor-thread-2) *** configChain ***
funqy-knative-events-quickstart-v1-deployment-59bb88bcf4-9jwdx user-container 2020-05-12 13:44:02,394 INFO  [org.acm.fun.SimpleFunctionChain] (executor-thread-1) *** annotatedChain ***
funqy-knative-events-quickstart-v1-deployment-59bb88bcf4-9jwdx user-container 2020-05-12 13:44:02,466 INFO  [org.acm.fun.SimpleFunctionChain] (executor-thread-2) *** lastChainLink ***
funqy-knative-events-quickstart-v1-deployment-59bb88bcf4-9jwdx user-container 2020-05-12 13:44:02,467 INFO  [org.acm.fun.SimpleFunctionChain] (executor-thread-2) Start::defaultChain::configChain::annotatedChain::lastChainLink</code></pre>
</div>
</div>
</div>
</div>