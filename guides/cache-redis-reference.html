<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>By default, Quarkus Cache uses Caffeine as backend.
It&#8217;s possible to use Redis instead.</p>
</div>
<div class="paragraph">
<p>Unresolved directive in cache-redis-reference.adoc - include::{includes}/extension-status.adoc[]</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="redis-as-cache-backend"><a class="anchor" href="#redis-as-cache-backend"></a>Redis as cache backend</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When using Redis as the backend for Quarkus cache, each cached item will be stored in Redis:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The backend uses the <em>&lt;default&gt;</em> Redis client (if not configured otherwise), so make sure it&#8217;s configured (or use the <a href="redis-dev-services">redis dev service</a>)</p>
</li>
<li>
<p>the Redis key is built as follows: <code>cache:$cache-name:$cache-key</code>, where <code>cache-key</code> is the key the application uses.</p>
</li>
<li>
<p>the value is encoded to JSON if needed</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="use-the-redis-backend"><a class="anchor" href="#use-the-redis-backend"></a>Use the Redis backend</h2>
<div class="sectionbody">
<div class="paragraph">
<p>First, you need to add the <code>quarkus-redis-cache</code> extension to your project:</p>
</div>
<div class="listingblock primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-redis-cache&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary asciidoc-tabs-target-sync-gradle">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-gradle hljs" data-lang="gradle">implementation("io.quarkus:quarkus-redis-cache")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, use the <code>@CacheResult</code> and others cache annotations as explained in the <a href="cache">Quarkus Cache guide</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@GET
@Path("/{keyElement1}/{keyElement2}/{keyElement3}")
@CacheResult(cacheName = "expensiveResourceCache")
public ExpensiveResponse getExpensiveResponse(@PathParam("keyElement1") @CacheKey String keyElement1,
        @PathParam("keyElement2") @CacheKey String keyElement2, @PathParam("keyElement3") @CacheKey String keyElement3,
        @QueryParam("foo") String foo) {
    invocations.incrementAndGet();
    ExpensiveResponse response = new ExpensiveResponse();
    response.setResult(keyElement1 + " " + keyElement2 + " " + keyElement3 + " too!");
    return response;
}

@POST
@CacheInvalidateAll(cacheName = "expensiveResourceCache")
public void invalidateAll() {

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="redis-cache-configuration-reference"><a class="anchor" href="#redis-cache-configuration-reference"></a>Configure the Redis backend</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Redis backend uses the <code>&lt;default&gt;</code> Redis client.
See the <a href="redis-reference">Redis reference</a> to configure the access to Redis.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In dev mode, you can use the <a href="redis-dev-services">Redis Dev Service</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you want to use another Redis for your cache, configure the <code>client-name</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">quarkus.cache.redis.client-name=my-redis-for-cache</code></pre>
</div>
</div>
<div class="paragraph">
<p>When writing to Redis or reading from Redis, Quarkus needs to know the type.
Indeed, the objects need to be serialized and deserialized.
For that purpose, you may need to configure type (class names) of the key and value you want to cache.
At build time, Quarkus tries to deduce the types from the application code, but that decision can be overridden using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Default configuration
quarkus.cache.redis.key-type=java.lang.String
quarkus.cache.redis.value-type=org.acme.Person

# Configuration for `expensiveResourceCache`
quarkus.cache.redis.expensiveResourceCache.key-type=java.lang.String
quarkus.cache.redis.expensiveResourceCache.value-type=org.acme.Supes</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also configure the time to live of the cached entries:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Default configuration
quarkus.cache.redis.ttl=10s

# Configuration for `expensiveResourceCache`
quarkus.cache.redis.expensiveResourceCache.ttl=1h</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code>ttl</code> is not configured, the entry won&#8217;t be evicted.
You would need to invalidate the values using the <code>@CacheInvalidateAll</code> or <code>@CacheInvalidate</code> annotations.</p>
</div>
<div class="paragraph">
<p>The following table lists the supported properties:</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configure-the-redis-key"><a class="anchor" href="#configure-the-redis-key"></a>Configure the Redis key</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, the Redis backend stores the entry using the following keys: <code>cache:$cache-name:$cache-key</code>, where <code>cache-key</code> is the key the application uses.
So, you can find all the entries for a single cache using the Redis <code>KEYS</code> command: <code>KEYS cache:$cache-name:*</code></p>
</div>
<div class="paragraph">
<p>The <code>cache:$cache-name:</code> segment can be configured using the <code>prefix</code> property:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Default configuration
quarkus.cache.redis.prefix=my-cache

# Configuration for `expensiveResourceCache`
quarkus.cache.redis.expensiveResourceCache.prefix=my-expensive-cache</code></pre>
</div>
</div>
<div class="paragraph">
<p>In these cases, you can find all the keys managed by the default cache using <code>KEYS my-cache:*</code>, and all the keys managed by the <code>expensiveResourceCache</code> cache using: <code>KEYS my-expensive-cache:*</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="enable-optimistic-locking"><a class="anchor" href="#enable-optimistic-locking"></a>Enable optimistic locking</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The access to the cache can be <em>direct</em> or use <a href="https://redis.io/docs/manual/transactions/#optimistic-locking-using-check-and-set">optimistic locking</a>.
By default, optimistic locking is disabled.</p>
</div>
<div class="paragraph">
<p>You can enable optimistic locking using:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties"># Default configuration
quarkus.cache.redis.use-optimistic-locking=true

# Configuration for `expensiveResourceCache`
quarkus.cache.redis.expensiveResourceCache.use-optimistic-locking=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>When used, the key is <em>watched</em> and the <em>SET</em> command is executed in a transaction (<code>MULTI/EXEC</code>).</p>
</div>
</div>
</div>