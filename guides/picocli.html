<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://picocli.info/">Picocli</a> is an open source tool for creating rich command line applications.</p>
</div>
<div class="paragraph">
<p>Quarkus provides support for using Picocli. This guide contains examples of <code>picocli</code> extension usage.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you are not familiar with the Quarkus Command Mode, consider reading the <a href="command-mode-reference">Command Mode reference guide</a> first.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration"><a class="anchor" href="#configuration"></a>Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Once you have your Quarkus project configured you can add the <code>picocli</code> extension
to your project by running the following command in your project base directory.</p>
</div>
<div class="paragraph">
<p>Unresolved directive in picocli.adoc - include::{includes}/devtools/extension-add.adoc[]</p>
</div>
<div class="paragraph">
<p>This will add the following to your <code>pom.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-picocli&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="simple-command-line-application"><a class="anchor" href="#simple-command-line-application"></a>Simple command line application</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Simple PicocliApplication with only one <code>Command</code> can be created as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.acme.picocli;

import picocli.CommandLine;

import jakarta.enterprise.context.Dependent;
import jakarta.inject.Inject;

@CommandLine.Command <i class="conum" data-value="1"></i><b>(1)</b>
public class HelloCommand implements Runnable {

    @CommandLine.Option(names = {"-n", "--name"}, description = "Who will we greet?", defaultValue = "World")
    String name;

    private final GreetingService greetingService;

    public HelloCommand(GreetingService greetingService) { <i class="conum" data-value="2"></i><b>(2)</b>
        this.greetingService = greetingService;
    }

    @Override
    public void run() {
        greetingService.sayHello(name);
    }
}

@Dependent
class GreetingService {
    void sayHello(String name) {
        System.out.println("Hello " + name + "!");
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If there is only one class annotated with <code>picocli.CommandLine.Command</code> it will be used as entry point to Picocli CommandLine.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>All classes annotated with <code>picocli.CommandLine.Command</code> are registered as CDI beans.</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Beans with <code>@CommandLine.Command</code> should not use proxied scopes (e.g. do not use <code>@ApplicationScope</code>)
because Picocli will not be able to set field values in such beans. This extension will register classes with <code>@CommandLine.Command</code> annotation
using <code>@Depended</code> scope. If you need to use proxied scope, then annotate setter and not field, for example:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CommandLine.Command
@ApplicationScoped
public class EntryCommand {
    private String name;

    @CommandLine.Option(names = "-n")
    public void setName(String name) {
        this.name = name;
    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="command-line-application-with-multiple-commands"><a class="anchor" href="#command-line-application-with-multiple-commands"></a>Command line application with multiple Commands</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When multiple classes have the <code>picocli.CommandLine.Command</code> annotation, then one of them needs to be also annotated with <code>io.quarkus.picocli.runtime.annotations.TopCommand</code>.
This can be overwritten with the <code>quarkus.picocli.top-command</code> property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.acme.picocli;

import io.quarkus.picocli.runtime.annotations.TopCommand;
import picocli.CommandLine;

@TopCommand
@CommandLine.Command(mixinStandardHelpOptions = true, subcommands = {HelloCommand.class, GoodByeCommand.class})
public class EntryCommand {
}

@CommandLine.Command(name = "hello", description = "Greet World!")
class HelloCommand implements Runnable {

    @Override
    public void run() {
        System.out.println("Hello World!");
    }
}

@CommandLine.Command(name = "goodbye", description = "Say goodbye to World!")
class GoodByeCommand implements Runnable {

    @Override
    public void run() {
        System.out.println("Goodbye World!");
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="customizing-picocli-commandline-instance"><a class="anchor" href="#customizing-picocli-commandline-instance"></a>Customizing Picocli CommandLine instance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can customize CommandLine classes used by the <code>picocli</code> extension by producing your own bean instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.acme.picocli;

import io.quarkus.picocli.runtime.PicocliCommandLineFactory;
import io.quarkus.picocli.runtime.annotations.TopCommand;
import picocli.CommandLine;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.inject.Produces;

@TopCommand
@CommandLine.Command
public class EntryCommand implements Runnable {
    @CommandLine.Spec
    CommandLine.Model.CommandSpec spec;

    @Override
    public void run() {
        System.out.println("My name is: " + spec.name());
    }
}

@ApplicationScoped
class CustomConfiguration {

    @Produces
    CommandLine customCommandLine(PicocliCommandLineFactory factory) { <i class="conum" data-value="1"></i><b>(1)</b>
        return factory.create().setCommandName("CustomizedName");
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>PicocliCommandLineFactory</code> will create an instance of CommandLine with <code>TopCommand</code> and <code>CommandLine.IFactory</code> injected.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="different-entry-command-for-each-profile"><a class="anchor" href="#different-entry-command-for-each-profile"></a>Different entry command for each profile</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It is possible to create different entry command for each profile, using <code>@IfBuildProfile</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@ApplicationScoped
public class Config {

    @Produces
    @TopCommand
    @IfBuildProfile("dev")
    public Object devCommand() {
        return DevCommand.class; <i class="conum" data-value="1"></i><b>(1)</b>
    }

    @Produces
    @TopCommand
    @IfBuildProfile("prod")
    public Object prodCommand() {
        return new ProdCommand("Configured by me!");
    }

}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>You can return instance of <code>java.lang.Class</code> here. In such case <code>CommandLine</code> will try to instantiate this class using <code>CommandLine.IFactory</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configure-cdi-beans-with-parsed-arguments"><a class="anchor" href="#configure-cdi-beans-with-parsed-arguments"></a>Configure CDI Beans with parsed arguments</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can use <code>Event&lt;CommandLine.ParseResult&gt;</code> or just <code>CommandLine.ParseResult</code> to configure CDI beans based on arguments parsed by Picocli.
This event will be generated in <code>QuarkusApplication</code> class created by this extension. If you are providing your own <code>@QuarkusMain</code> this event will not be raised.
<code>CommandLine.ParseResult</code> is created from default <code>CommandLine</code> bean.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@CommandLine.Command
public class EntryCommand implements Runnable {

    @CommandLine.Option(names = "-c", description = "JDBC connection string")
    String connectionString;

    @Inject
    DataSource dataSource;

    @Override
    public void run() {
        try (Connection c = dataSource.getConnection()) {
            // Do something
        } catch (SQLException throwables) {
            // Handle error
        }
    }
}

@ApplicationScoped
class DatasourceConfiguration {

    @Produces
    @ApplicationScoped <i class="conum" data-value="1"></i><b>(1)</b>
    DataSource dataSource(CommandLine.ParseResult parseResult) {
        PGSimpleDataSource ds = new PGSimpleDataSource();
        ds.setURL(parseResult.matchedOption("c").getValue().toString());
        return ds;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@ApplicationScoped</code> used for lazy initialization</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="providing-own-quarkusmain"><a class="anchor" href="#providing-own-quarkusmain"></a>Providing own QuarkusMain</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can also provide your own application entry point annotated with <code>QuarkusMain</code> (as described in <a href="command-mode-reference">Command Mode reference guide</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package com.acme.picocli;

import io.quarkus.runtime.QuarkusApplication;
import io.quarkus.runtime.annotations.QuarkusMain;
import picocli.CommandLine;

import jakarta.inject.Inject;

@QuarkusMain
@CommandLine.Command(name = "demo", mixinStandardHelpOptions = true)
public class ExampleApp implements Runnable, QuarkusApplication {
    @Inject
    CommandLine.IFactory factory; <i class="conum" data-value="1"></i><b>(1)</b>

    @Override
    public void run() {
        // business logic
    }

    @Override
    public int run(String... args) throws Exception {
        return new CommandLine(this, factory).execute(args);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Quarkus-compatible <code>CommandLine.IFactory</code> bean created by <code>picocli</code> extension.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="native-mode-support"><a class="anchor" href="#native-mode-support"></a>Native mode support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This extension uses the Quarkus standard build steps mechanism to support GraalVM Native images. In the exceptional case that incompatible changes in a future picocli release cause any issue, the following configuration can be used to fall back to the annotation processor from the picocli project as a temporary workaround:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;info.picocli&lt;/groupId&gt;
  &lt;artifactId&gt;picocli-codegen&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For Gradle, you need to add the following in <code>dependencies</code> section of the <code>build.gradle</code> file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">annotationProcessor enforcedPlatform("${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}")
annotationProcessor 'info.picocli:picocli-codegen'</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="development-mode"><a class="anchor" href="#development-mode"></a>Development Mode</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the development mode, i.e. when running <code>mvn quarkus:dev</code>, the application is executed and restarted every time the <code>Space bar</code> key is pressed. You can also pass arguments to your command line app via the <code>quarkus.args</code> system property, e.g. <code>mvn quarkus:dev -Dquarkus.args='--help'</code> and <code>mvn quarkus:dev -Dquarkus.args='-c -w --val 1'</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kubernetes-support"><a class="anchor" href="#kubernetes-support"></a>Kubernetes support</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Once you have your command line application, you can also generate the resources necessary to install and use this application in Kubernetes by adding the <code>kubernetes</code> extension. To install the <code>kubernetes</code> extension, run the following command in your project base directory.</p>
</div>
<div class="paragraph">
<p>Unresolved directive in picocli.adoc - include::{includes}/devtools/extension-add.adoc[]</p>
</div>
<div class="paragraph">
<p>This will add the following to your <code>pom.xml</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.quarkus&lt;/groupId&gt;
    &lt;artifactId&gt;quarkus-kubernetes&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And, next, build the application with:</p>
</div>
<div class="paragraph">
<p>Unresolved directive in picocli.adoc - include::{includes}/devtools/build.adoc[]</p>
</div>
<div class="paragraph">
<p>The Kubernetes extension will detect the presence of the Picocli extension and hence generate a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/">Job</a> resource instead of a <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a> resource in the <code>target/kubernetes/</code> directory.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
If you don&#8217;t want to generate a Job resource, you can specify the resource you want to generate using the property <code>quarkus.kubernetes.deployment-kind</code>. For example, if you want to generate a Deployment resource, use <code>quarkus.kubernetes.deployment-kind=Deployment</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Moreover, you can provide the arguments that will be used by the Kubernetes job via the property <code>quarkus.kubernetes.arguments</code>. For example, after adding the property <code>quarkus.kubernetes.arguments=A,B</code> and building your project, the following Job resource will be generated:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">apiVersion: batch/v1
kind: Job
metadata:
  labels:
    app.kubernetes.io/name: app
    app.kubernetes.io/version: 0.1-SNAPSHOT
  name: app
spec:
  completionMode: NonIndexed
  selector:
    matchLabels:
      app.kubernetes.io/name: app
      app.kubernetes.io/version: 0.1-SNAPSHOT
  suspend: false
  template:
    metadata:
      labels:
        app.kubernetes.io/name: app
        app.kubernetes.io/version: 0.1-SNAPSHOT
    spec:
      containers:
        - args:
            - A
            - B
          env:
            - name: KUBERNETES_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          image: docker.io/user/app:0.1-SNAPSHOT
          imagePullPolicy: Always
          name: app
          ports:
            - containerPort: 8080
              name: http
              protocol: TCP
      restartPolicy: OnFailure
      terminationGracePeriodSeconds: 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the Kubernetes job will be launched every time it is installed in Kubernetes. You can know more about how to run Kubernetes jobs in this <a href="https://kubernetes.io/docs/concepts/workloads/controllers/job/#running-an-example-job">document</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration-reference"><a class="anchor" href="#configuration-reference"></a>Configuration Reference</h2>
<div class="sectionbody">

</div>
</div>