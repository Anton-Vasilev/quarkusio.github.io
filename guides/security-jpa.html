<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus provides a Jakarta Persistence (formerly known as JPA) identity provider, similar to the <a href="security-jdbc">JDBC identity provider</a>, suitable for use with the <a href="security-basic-authentication">Basic</a> and <a href="security-authentication-mechanisms#form-auth">Form-based</a> Quarkus Security mechanisms, which require a combination of username and password credentials.</p>
</div>
<div class="paragraph">
<p>The Jakarta Persistence <code>IdentityProvider</code> creates a <code>SecurityIdentity</code> instance, which is used during user authentication to verify and authorize access requests making your Quarkus application secure.</p>
</div>
<div class="paragraph">
<p>For an example of practical use of Basic authentication and Jakarta Persistence, see the <a href="security-basic-authentication-tutorial">Secure a Quarkus application with Basic authentication and Jakarta Persistence</a> tutorial.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jakarta-persistence-entity-specification"><a class="anchor" href="#jakarta-persistence-entity-specification"></a>Jakarta Persistence entity specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Quarkus security offers a Jakarta Persistence integration to collect usernames, passwords, and roles, and store them into Jakarta Persistence database entities.</p>
</div>
<div class="paragraph">
<p>The following Jakarta Persistence entity specification demonstrates how users' information needs to be stored in a Jakarta Persistence entity and properly mapped so that Quarkus can retrieve this information from a database.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <code>@UserDefinition</code> annotation must be present on a Jakarta Persistence entity, regardless of whether <a href="https://quarkus.io/guides/hibernate-orm-panache">simplified Hibernate ORM with Panache</a> is used or not.</p>
</li>
<li>
<p>The <code>@Username</code> and <code>@Password</code> field types are always <code>String</code>.</p>
</li>
<li>
<p>The <code>@Roles</code> field must either be <code>String</code>, <code>Collection&lt;String&gt;</code>, or a <code>Collection&lt;X&gt;</code>, where <code>X</code> is an entity class with a single <code>String</code> field annotated as <code>@RolesValue</code>.</p>
</li>
<li>
<p>Each <code>String</code> role element type is parsed as a comma-separated list of roles.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example demonstrates storing security information by adding annotations to the <code>user</code> entity:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">package org.acme.security.jpa;

import jakarta.persistence.Entity;
import jakarta.persistence.Table;

import io.quarkus.hibernate.orm.panache.PanacheEntity;
import io.quarkus.elytron.security.common.BcryptUtil;
import io.quarkus.security.jpa.Password;
import io.quarkus.security.jpa.Roles;
import io.quarkus.security.jpa.UserDefinition;
import io.quarkus.security.jpa.Username;

@Entity
@Table(name = "test_user")
@UserDefinition <i class="conum" data-value="1"></i><b>(1)</b>
public class User extends PanacheEntity {
    @Username <i class="conum" data-value="2"></i><b>(2)</b>
    public String username;
    @Password <i class="conum" data-value="3"></i><b>(3)</b>
    public String password;
    @Roles <i class="conum" data-value="4"></i><b>(4)</b>
    public String role;

    /**
     * Adds a new user to the database
     * @param username the username
     * @param password the unencrypted password (it will be encrypted with bcrypt)
     * @param role the comma-separated roles
     */
    public static void add(String username, String password, String role) { <i class="conum" data-value="5"></i><b>(5)</b>
        User user = new User();
        user.username = username;
        user.password = BcryptUtil.bcryptHash(password);
        user.role = role;
        user.persist();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>security-jpa</code> extension initializes only if a single entity is annotated with <code>@UserDefinition</code>.</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The <code>@UserDefinition</code> annotation must be present on a single entity, either a regular Hibernate ORM entity or a Hibernate ORM with a Panache entity.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Indicates the field used for the username.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Indicates the field used for the password.
By default, <code>security-jpa</code> uses bcrypt-hashed passwords, or you can configure plain text or custom passwords instead.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>This indicates the comma-separated list of roles added to the target principal representation attributes.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>This method allows you to add users while hashing passwords with the proper <code>bcrypt</code> hash.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jakarta-persistence-entity-as-storage-of-roles"><a class="anchor" href="#jakarta-persistence-entity-as-storage-of-roles"></a>Jakarta Persistence entity as storage of roles</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Use the following example to store roles inside another Jakarta Persistence entity:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@UserDefinition
@Table(name = "test_user")
@Entity
public class User extends PanacheEntity {
    @Username
    public String name;

    @Password
    public String pass;

    @ManyToMany
    @Roles
    public List&lt;Role&gt; roles = new ArrayList&lt;&gt;();
}

@Entity
public class Role extends PanacheEntity {

    @ManyToMany(mappedBy = "roles")
    public List&lt;ExternalRolesUserEntity&gt; users;

    @RolesValue
    public String role;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="password-storage-and-hashing"><a class="anchor" href="#password-storage-and-hashing"></a>Password storage and hashing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>When developing applications with Quarkus, you can decide how to manage password storage and hashing. You can choose to keep the default password and hashing settings of Quarkus, or you can hash passwords manually.</p>
</div>
<div class="paragraph">
<p>With the default option, passwords are stored and hashed with <a href="https://en.wikipedia.org/wiki/Bcrypt">bcrypt</a> under the
<a href="https://en.wikipedia.org/wiki/Crypt_&#169;">Modular Crypt Format</a> (MCF).
While using MCF, the hashing algorithm, iteration count, and salt are stored as a part of the hashed value.
As such, we do not need dedicated columns to keep them.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In cryptography, a salt is a name for random data used as an additional input to a one-way function that hashes data, a password, or a passphrase.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For manual password hashing, create a class that implements the `CustomPasswordProvider`as shown in the example below.</p>
</div>
<div class="paragraph">
<p>The following snippet shows how to set a custom password provider that uses the SHA256 hashing algorithm.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@UserDefinition
@Table(name = "test_user")
@Entity
public class CustomPasswordUserEntity {
    @Id
    @GeneratedValue
    public Long id;

    @Column(name = "username")
    @Username
    public String name;

    @Column(name = "password")
    @Password(value = PasswordType.CUSTOM, provider = CustomPasswordProvider.class)
    public String pass;

    @Roles
    public String role;
}

public class CustomPasswordProvider implements PasswordProvider {
    @Override
    public Password getPassword(String pass) {
        byte[] digest = DatatypeConverter.parseHexBinary(pass);
        return SimpleDigestPassword.createRaw(SimpleDigestPassword.ALGORITHM_SIMPLE_DIGEST_SHA_256, digest);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For quick creation of a hashed password, use <code>String BcryptUtil.bcryptHash(String password)</code>, which defaults to creating a random salt and hashing in ten iterations.
This method also allows specifying the desired amount of iterations and the salt used.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>For applications running in a production environment, do not store passwords as plain text.</p>
</div>
<div class="paragraph">
<p>However, it is possible to store passwords as plain text with the <code>@Password(PasswordType.CLEAR)</code> annotation when operating in a test environment.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references"><a class="anchor" href="#references"></a>References</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="security-basic-authentication-tutorial">Secure a Quarkus application with Basic authentication and Jakarta Persistence</a></p>
</li>
<li>
<p><a href="security-identity-providers">Identity providers</a></p>
</li>
<li>
<p><a href="security-overview">Quarkus Security overview</a></p>
</li>
</ul>
</div>
</div>
</div>